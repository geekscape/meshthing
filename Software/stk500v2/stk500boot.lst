   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB9:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** File:      $Id: stk500boot.c,v 1.11 2006/06/25 12:39:17 peter Exp $
   6:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   7:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   8:stk500boot.c  **** License:   GNU General Public License
   9:stk500boot.c  **** 
  10:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  11:stk500boot.c  **** Date:      17 October 2007
  12:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  13:stk500boot.c  **** Compiler:  WINAVR20060421
  14:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  15:stk500boot.c  **** 
  16:stk500boot.c  **** DESCRIPTION:
  17:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  18:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  19:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  20:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  21:stk500boot.c  ****     "reset" vector in Application area.
  22:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  23:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  24:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  25:stk500boot.c  **** 
  26:stk500boot.c  **** USAGE:
  27:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  28:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  29:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  30:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  31:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  32:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  33:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  34:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  35:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  36:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  37:stk500boot.c  ****     - AVRISP will detect the bootloader
  38:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  39:stk500boot.c  **** 
  40:stk500boot.c  **** Note:
  41:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  42:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  43:stk500boot.c  ****     Flash is always erased before programming.
  44:stk500boot.c  **** 
  45:stk500boot.c  **** 	AVRdude:
  46:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  47:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  48:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  49:stk500boot.c  **** 
  50:stk500boot.c  **** NOTES:
  51:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  52:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  53:stk500boot.c  **** 
  54:stk500boot.c  **** LICENSE:
  55:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  56:stk500boot.c  **** 
  57:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  58:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  59:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  60:stk500boot.c  ****     any later version.
  61:stk500boot.c  **** 
  62:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  63:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  64:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  65:stk500boot.c  ****     GNU General Public License for more details.
  66:stk500boot.c  **** 
  67:stk500boot.c  **** *****************************************************************************/
  68:stk500boot.c  **** 
  69:stk500boot.c  **** //************************************************************************
  70:stk500boot.c  **** //*	Edit History
  71:stk500boot.c  **** //************************************************************************
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  74:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  76:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  78:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  79:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  80:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  81:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  82:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  83:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  84:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  86:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence 
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  89:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  90:stk500boot.c  **** //************************************************************************
  91:stk500boot.c  **** 
  92:stk500boot.c  **** //************************************************************************
  93:stk500boot.c  **** //*	these are used to test issues
  94:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  95:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  96:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence 
  97:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).  
  98:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  99:stk500boot.c  **** #define	_FIX_ISSUE_505_
 100:stk500boot.c  **** //************************************************************************
 101:stk500boot.c  **** //*	Issue 181: added watch dog timmer support
 102:stk500boot.c  **** #define	_FIX_ISSUE_181_
 103:stk500boot.c  **** 
 104:stk500boot.c  **** #include	<inttypes.h>
 105:stk500boot.c  **** #include	<avr/io.h>
 106:stk500boot.c  **** #include	<avr/interrupt.h>
 107:stk500boot.c  **** #include	<avr/boot.h>
 108:stk500boot.c  **** #include	<avr/pgmspace.h>
 109:stk500boot.c  **** #include	<util/delay.h>
 110:stk500boot.c  **** #include	<avr/eeprom.h>
 111:stk500boot.c  **** #include	<avr/common.h>
 112:stk500boot.c  **** #include	<stdlib.h>
 113:stk500boot.c  **** #include	"command.h"
 114:stk500boot.c  **** 
 115:stk500boot.c  **** 
 116:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 117:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR) || defin
 118:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 119:stk500boot.c  **** 	#define		ENABLE_MONITOR
 120:stk500boot.c  **** 	static void	RunMonitor(void);
 121:stk500boot.c  **** #endif
 122:stk500boot.c  **** 
 123:stk500boot.c  **** #ifndef EEWE
 124:stk500boot.c  **** 	#define EEWE    1
 125:stk500boot.c  **** #endif
 126:stk500boot.c  **** #ifndef EEMWE
 127:stk500boot.c  **** 	#define EEMWE   2
 128:stk500boot.c  **** #endif
 129:stk500boot.c  **** 
 130:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 131:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 132:stk500boot.c  **** 
 133:stk500boot.c  **** 
 134:stk500boot.c  **** /*
 135:stk500boot.c  ****  * Uncomment the following lines to save code space
 136:stk500boot.c  ****  */
 137:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 138:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 139:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 140:stk500boot.c  **** //
 141:stk500boot.c  **** 
 142:stk500boot.c  **** 
 143:stk500boot.c  **** 
 144:stk500boot.c  **** //************************************************************************
 145:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 146:stk500boot.c  **** //*	indicates that bootloader is active
 147:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 148:stk500boot.c  **** //************************************************************************
 149:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 150:stk500boot.c  **** 
 151:stk500boot.c  **** #ifdef _MEGA_BOARD_
 152:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 153:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 154:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 155:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 156:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 157:stk500boot.c  **** 	//*	onbarod led is PORTE4
 158:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 159:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 160:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 161:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined(_CEREBOT_II_BOARD_)
 162:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 163:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 164:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 165:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 166:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 167:stk500boot.c  **** #elif defined( _PENGUINO_ )
 168:stk500boot.c  **** 	//*	this is for the Penguino
 169:stk500boot.c  **** 	//*	onbarod led is PORTE4
 170:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 171:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 172:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 173:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 174:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 175:stk500boot.c  **** 	//*	onbarod led is PORTE4
 176:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 177:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 178:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 179:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 180:stk500boot.c  **** 	//*	onbarod led is PORTA7
 181:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 182:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 183:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 184:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 185:stk500boot.c  **** 
 186:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 187:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 188:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 189:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 190:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 191:stk500boot.c  **** 
 192:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 193:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 194:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 195:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 196:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 197:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 198:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 199:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 200:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 201:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 202:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 203:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 204:stk500boot.c  **** #elif defined( _AVRLIP_ )
 205:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 206:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 207:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 208:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 209:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 210:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 211:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 212:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 213:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 214:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 215:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 216:stk500boot.c  **** #elif defined( _BOARD_STK525_ )
 217:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 218:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 219:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 220:stk500boot.c  **** #elif defined( _BOARD_MESHTHING_2564RFR2_ )
 221:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 222:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 223:stk500boot.c  **** 	#define PROGLED_PIN		PINB1
 224:stk500boot.c  **** #else
 225:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 226:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 227:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 228:stk500boot.c  **** #endif
 229:stk500boot.c  **** 
 230:stk500boot.c  **** 
 231:stk500boot.c  **** 
 232:stk500boot.c  **** /*
 233:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 234:stk500boot.c  ****  */
 235:stk500boot.c  **** #ifndef F_CPU
 236:stk500boot.c  **** 	#define F_CPU 16000000UL
 237:stk500boot.c  **** #endif
 238:stk500boot.c  **** 
 239:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 240:stk500boot.c  **** /*
 241:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 242:stk500boot.c  ****  */
 243:stk500boot.c  **** 
 244:stk500boot.c  **** #ifndef BAUDRATE
 245:stk500boot.c  **** 	#define BAUDRATE 115200
 246:stk500boot.c  **** #endif
 247:stk500boot.c  **** 
 248:stk500boot.c  **** /*
 249:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 250:stk500boot.c  ****  */
 251:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 252:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 253:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 254:stk500boot.c  **** 	#else
 255:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 256:stk500boot.c  **** 	#endif
 257:stk500boot.c  **** #endif
 258:stk500boot.c  **** 
 259:stk500boot.c  **** /*
 260:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 261:stk500boot.c  ****  */
 262:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 263:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 264:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 265:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 266:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 267:stk500boot.c  **** 
 268:stk500boot.c  **** /*
 269:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 270:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 271:stk500boot.c  ****  */
 272:stk500boot.c  **** //#define BOOTSIZE 1024
 273:stk500boot.c  **** #if FLASHEND > 0x0F000
 274:stk500boot.c  **** 	#define BOOTSIZE 8192
 275:stk500boot.c  **** #else
 276:stk500boot.c  **** 	#define BOOTSIZE 2048
 277:stk500boot.c  **** #endif
 278:stk500boot.c  **** 
 279:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 280:stk500boot.c  **** 
 281:stk500boot.c  **** /*
 282:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 283:stk500boot.c  ****  */
 284:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 285:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 286:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 287:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 288:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 289:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 290:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 291:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 292:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 293:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 294:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 295:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 296:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 297:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 298:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 299:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 300:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 301:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 302:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 303:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 304:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 305:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 306:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 307:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 308:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 309:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 310:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 311:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 312:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 313:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 314:stk500boot.c  **** #elif defined(__AVR_ATmega256RFR2__)
 315:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1ea803
 316:stk500boot.c  **** #elif defined(__AVR_ATmega2564RFR2__)
 317:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1ea803
 318:stk500boot.c  **** #else
 319:stk500boot.c  **** 	#error "no signature definition for MCU available"
 320:stk500boot.c  **** #endif
 321:stk500boot.c  **** 
 322:stk500boot.c  **** #if defined(_BOARD_MESHTHING_2564RFR2_)
 323:stk500boot.c  **** 	#define UART_STATUS_REG 		UCSR0A
 324:stk500boot.c  **** 
 325:stk500boot.c  **** 	#define UDRE  UDRE0
 326:stk500boot.c  **** 
 327:stk500boot.c  **** 	#define UART_CONTROL_REG 		UCSR0B
 328:stk500boot.c  **** 	#define UART_ENABLE_RECEIVER  	RXEN0
 329:stk500boot.c  **** 	#define UART_ENABLE_TRANSMITTER TXEN0
 330:stk500boot.c  **** 
 331:stk500boot.c  **** 	#define UCSRC UCSR0C
 332:stk500boot.c  **** 
 333:stk500boot.c  **** 	#define UART_BAUD_RATE_LOW 		UBRR0L
 334:stk500boot.c  **** 	#define UART_DATA_REG 			UDR0
 335:stk500boot.c  **** 
 336:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 337:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 338:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED		U2X0
 339:stk500boot.c  **** 
 340:stk500boot.c  **** #elif defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 341:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L	//
 342:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A 	//
 343:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B 	//
 344:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1		//
 345:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1		//
 346:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1		//
 347:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1		//
 348:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1	//
 349:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1	//
 350:stk500boot.c  **** 
 351:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 352:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 353:stk500boot.c  **** 	/* ATMega8 with one USART */
 354:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 355:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 356:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 357:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 358:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 359:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 360:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 361:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 362:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 363:stk500boot.c  **** 
 364:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 365:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 366:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 367:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 368:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 369:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 370:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 371:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 372:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 373:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 374:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 375:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 376:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 377:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 378:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 379:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 380:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 381:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 382:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 383:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 384:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 385:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 386:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 387:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 388:stk500boot.c  **** 	//* catch all
 389:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 390:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 391:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 392:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 393:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 394:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 395:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 396:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 397:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 398:stk500boot.c  **** #else
 399:stk500boot.c  **** 	#error "no UART definition for MCU available"
 400:stk500boot.c  **** #endif
 401:stk500boot.c  **** 
 402:stk500boot.c  **** 
 403:stk500boot.c  **** 
 404:stk500boot.c  **** /*
 405:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 406:stk500boot.c  ****  */
 407:stk500boot.c  **** 
 408:stk500boot.c  **** #if defined(_BOARD_MESHTHING_2564RFR2_)
 409:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (xtalCpu / 16 / baudRate - 1)
 410:stk500boot.c  **** #elif defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 411:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 412:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 413:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 414:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 415:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 416:stk500boot.c  **** #else
 417:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 418:stk500boot.c  **** #endif
 419:stk500boot.c  **** 
 420:stk500boot.c  **** 
 421:stk500boot.c  **** /*
 422:stk500boot.c  ****  * States used in the receive state machine
 423:stk500boot.c  ****  */
 424:stk500boot.c  **** #define	ST_START		0
 425:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 426:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 427:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 428:stk500boot.c  **** #define ST_GET_TOKEN	4
 429:stk500boot.c  **** #define ST_GET_DATA		5
 430:stk500boot.c  **** #define	ST_GET_CHECK	6
 431:stk500boot.c  **** #define	ST_PROCESS		7
 432:stk500boot.c  **** 
 433:stk500boot.c  **** /*
 434:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 435:stk500boot.c  ****  */
 436:stk500boot.c  **** #if defined(RAMPZ)
 437:stk500boot.c  **** 	typedef uint32_t address_t;
 438:stk500boot.c  **** #else
 439:stk500boot.c  **** 	typedef uint16_t address_t;
 440:stk500boot.c  **** #endif
 441:stk500boot.c  **** 
 442:stk500boot.c  **** /*
 443:stk500boot.c  ****  * function prototypes
 444:stk500boot.c  ****  */
 445:stk500boot.c  **** static void sendchar(char c);
 446:stk500boot.c  **** static unsigned char recchar(void);
 447:stk500boot.c  **** 
 448:stk500boot.c  **** /*
 449:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 450:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 451:stk500boot.c  ****  */
 452:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 453:stk500boot.c  **** #include <avr/sfr_defs.h>
 454:stk500boot.c  **** 
 455:stk500boot.c  **** //#define	SPH_REG	0x3E
 456:stk500boot.c  **** //#define	SPL_REG	0x3D
 457:stk500boot.c  **** 
 458:stk500boot.c  **** //*****************************************************************************
 459:stk500boot.c  **** void __jumpMain(void)
 460:stk500boot.c  **** {
 461:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 462:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 463:stk500boot.c  **** 
 464:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 465:stk500boot.c  **** 
 466:stk500boot.c  **** //*	set stack pointer to top of RAM
 467:stk500boot.c  **** 
 468:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 469:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 470:stk500boot.c  **** 
 471:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 472:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 473:stk500boot.c  **** 
 474:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 475:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 476:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 477:stk500boot.c  **** }
 478:stk500boot.c  **** 
 479:stk500boot.c  **** 
 480:stk500boot.c  **** //*****************************************************************************
 481:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 482:stk500boot.c  **** {
 483:stk500boot.c  **** 	unsigned int i;
 484:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 485:stk500boot.c  **** 	{
 486:stk500boot.c  **** 		_delay_ms(0.5);
 487:stk500boot.c  **** 	}
 488:stk500boot.c  **** }
 489:stk500boot.c  **** 
 490:stk500boot.c  **** 
 491:stk500boot.c  **** //*****************************************************************************
 492:stk500boot.c  **** /*
 493:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 494:stk500boot.c  ****  */
 495:stk500boot.c  **** static void sendchar(char c)
 496:stk500boot.c  **** {
  15               		.loc 1 496 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 497:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 497 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 498:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 498 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 499:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 499 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34 0016 0895      		ret
  35               		.cfi_endproc
  36               	.LFE9:
  38               		.section	.text.unlikely,"ax",@progbits
  40               	recchar:
  41               	.LFB11:
 500:stk500boot.c  **** }
 501:stk500boot.c  **** 
 502:stk500boot.c  **** 
 503:stk500boot.c  **** //************************************************************************
 504:stk500boot.c  **** static int	Serial_Available(void)
 505:stk500boot.c  **** {
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 507:stk500boot.c  **** }
 508:stk500boot.c  **** 
 509:stk500boot.c  **** 
 510:stk500boot.c  **** //*****************************************************************************
 511:stk500boot.c  **** /*
 512:stk500boot.c  ****  * Read single byte from USART, block if no data available
 513:stk500boot.c  ****  */
 514:stk500boot.c  **** static unsigned char recchar(void)
 515:stk500boot.c  **** {
  42               		.loc 1 515 0
  43               		.cfi_startproc
  44               	/* prologue: function */
  45               	/* frame size = 0 */
  46               	/* stack size = 0 */
  47               	.L__stack_usage = 0
  48               	.L8:
 516:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  49               		.loc 1 516 0 discriminator 1
  50 0000 8091 C000 		lds r24,192
  51 0004 87FF      		sbrs r24,7
  52 0006 00C0      		rjmp .L8
 517:stk500boot.c  **** 	{
 518:stk500boot.c  **** 		// wait for data
 519:stk500boot.c  **** 	}
 520:stk500boot.c  **** 	return UART_DATA_REG;
  53               		.loc 1 520 0
  54 0008 8091 C600 		lds r24,198
 521:stk500boot.c  **** }
  55               		.loc 1 521 0
  56 000c 0895      		ret
  57               		.cfi_endproc
  58               	.LFE11:
  60               		.section	.init9,"ax",@progbits
  61               	.global	__jumpMain
  63               	__jumpMain:
  64               	.LFB7:
 460:stk500boot.c  **** {
  65               		.loc 1 460 0
  66               		.cfi_startproc
  67               	/* prologue: naked */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
 464:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
  71               		.loc 1 464 0
  72               	/* #APP */
  73               	 ;  464 "stk500boot.c" 1
  74               		.set __stack, -32257
  75               	 ;  0 "" 2
 468:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
  76               		.loc 1 468 0
  77               	 ;  468 "stk500boot.c" 1
  78 0000 01E8      		ldi	16, 129
  79               	 ;  0 "" 2
 469:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  80               		.loc 1 469 0
  81               	 ;  469 "stk500boot.c" 1
  82 0002 0EBF      		out 62,16
  83               	 ;  0 "" 2
 471:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
  84               		.loc 1 471 0
  85               	 ;  471 "stk500boot.c" 1
  86 0004 0FEF      		ldi	16, 255
  87               	 ;  0 "" 2
 472:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  88               		.loc 1 472 0
  89               	 ;  472 "stk500boot.c" 1
  90 0006 0DBF      		out 61,16
  91               	 ;  0 "" 2
 474:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
  92               		.loc 1 474 0
  93               	 ;  474 "stk500boot.c" 1
  94 0008 1124      		clr __zero_reg__
  95               	 ;  0 "" 2
 475:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  96               		.loc 1 475 0
  97               	 ;  475 "stk500boot.c" 1
  98 000a 1FBE      		out 63, __zero_reg__
  99               	 ;  0 "" 2
 476:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 100               		.loc 1 476 0
 101               	 ;  476 "stk500boot.c" 1
 102 000c 0C94 0000 		jmp main
 103               	 ;  0 "" 2
 104               	/* epilogue start */
 477:stk500boot.c  **** }
 105               		.loc 1 477 0
 106               	/* #NOAPP */
 107               		.cfi_endproc
 108               	.LFE7:
 110               		.text
 111               	.global	delay_ms
 113               	delay_ms:
 114               	.LFB8:
 482:stk500boot.c  **** {
 115               		.loc 1 482 0
 116               		.cfi_startproc
 117               	.LVL2:
 118               	/* prologue: function */
 119               	/* frame size = 0 */
 120               	/* stack size = 0 */
 121               	.L__stack_usage = 0
 484:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 122               		.loc 1 484 0
 123 0018 20E0      		ldi r18,0
 124 001a 30E0      		ldi r19,0
 125 001c 00C0      		rjmp .L12
 126               	.LVL3:
 127               	.L13:
 128               	.LBB43:
 129               	.LBB44:
 130               		.file 2 "/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/includ
   1:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   6:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
   9:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  12:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  17:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  21:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  33:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  35:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  38:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  41:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  42:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  46:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \code
  49:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  54:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     used.
  58:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  59:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  68:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  77:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  81:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** */
  82:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  83:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  87:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  88:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  93:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  94:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
  97:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
  98:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #endif
 103:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 104:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** /**
 105:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 107:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 109:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 112:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 114:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 120:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 125:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 129:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 132:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 140:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****  */
 141:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** void
 142:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** {
 144:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 153:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 156:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 159:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#else
 160:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 
 164:/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 131               		.loc 2 164 0
 132 001e EFEC      		ldi r30,lo8(1999)
 133 0020 F7E0      		ldi r31,hi8(1999)
 134 0022 3197      		1: sbiw r30,1
 135 0024 01F4      		brne 1b
 136 0026 00C0      		rjmp .
 137 0028 0000      		nop
 138               	.LBE44:
 139               	.LBE43:
 484:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 140               		.loc 1 484 0
 141 002a 2F5F      		subi r18,-1
 142 002c 3F4F      		sbci r19,-1
 143               	.LVL4:
 144               	.L12:
 484:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 145               		.loc 1 484 0 is_stmt 0 discriminator 1
 146 002e 2817      		cp r18,r24
 147 0030 3907      		cpc r19,r25
 148 0032 01F4      		brne .L13
 149               	/* epilogue start */
 488:stk500boot.c  **** }
 150               		.loc 1 488 0 is_stmt 1
 151 0034 0895      		ret
 152               		.cfi_endproc
 153               	.LFE8:
 155               	.global	PrintFromPROGMEM
 157               	PrintFromPROGMEM:
 158               	.LFB14:
 522:stk500boot.c  **** 
 523:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 524:stk500boot.c  **** //*****************************************************************************
 525:stk500boot.c  **** static unsigned char recchar_timeout(void)
 526:stk500boot.c  **** {
 527:stk500boot.c  **** uint32_t count = 0;
 528:stk500boot.c  **** 
 529:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 530:stk500boot.c  **** 	{
 531:stk500boot.c  **** 		// wait for data
 532:stk500boot.c  **** 		count++;
 533:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 534:stk500boot.c  **** 		{
 535:stk500boot.c  **** 		unsigned int	data;
 536:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 537:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 538:stk500boot.c  **** 		#else
 539:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 540:stk500boot.c  **** 		#endif
 541:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 542:stk500boot.c  **** 			{
 543:stk500boot.c  **** 				asm volatile(
 544:stk500boot.c  **** 						"clr	r30		\n\t"
 545:stk500boot.c  **** 						"clr	r31		\n\t"
 546:stk500boot.c  **** 						"ijmp	\n\t"
 547:stk500boot.c  **** 						);
 548:stk500boot.c  **** 			}
 549:stk500boot.c  **** 			count	=	0;
 550:stk500boot.c  **** 		}
 551:stk500boot.c  **** 	}
 552:stk500boot.c  **** 	return UART_DATA_REG;
 553:stk500boot.c  **** }
 554:stk500boot.c  **** 
 555:stk500boot.c  **** //*	for watch dog timer startup
 556:stk500boot.c  **** void (*app_start)(void) = 0x0000;
 557:stk500boot.c  **** 
 558:stk500boot.c  **** 
 559:stk500boot.c  **** //*****************************************************************************
 560:stk500boot.c  **** int main(void)
 561:stk500boot.c  **** {
 562:stk500boot.c  **** 	address_t		address			=	0;
 563:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 564:stk500boot.c  **** 	unsigned char	msgParseState;
 565:stk500boot.c  **** 	unsigned int	ii				=	0;
 566:stk500boot.c  **** 	unsigned char	checksum		=	0;
 567:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 568:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 569:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 570:stk500boot.c  **** 	unsigned char	c, *p;
 571:stk500boot.c  **** 	unsigned char   isLeave = 0;
 572:stk500boot.c  **** 
 573:stk500boot.c  **** 	unsigned long	boot_timeout;
 574:stk500boot.c  **** 	unsigned long	boot_timer;
 575:stk500boot.c  **** 	unsigned int	boot_state;
 576:stk500boot.c  **** #ifdef ENABLE_MONITOR
 577:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 578:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 579:stk500boot.c  **** #endif
 580:stk500boot.c  **** 
 581:stk500boot.c  **** 	//*	some chips dont set the stack properly
 582:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 583:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 584:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 585:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 586:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 587:stk500boot.c  **** 
 588:stk500boot.c  **** #ifdef _FIX_ISSUE_181_
 589:stk500boot.c  **** 	//************************************************************************
 590:stk500boot.c  **** 	//*	Dec 29,	2011	<MLS> Issue #181, added watch dog timmer support
 591:stk500boot.c  **** 	//*	handle the watch dog timer
 592:stk500boot.c  **** 	uint8_t	mcuStatusReg;
 593:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 594:stk500boot.c  **** 
 595:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 596:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 597:stk500boot.c  **** 	MCUSR	=	0;
 598:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 599:stk500boot.c  **** 	WDTCSR	=	0;
 600:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 601:stk500boot.c  **** 	// check if WDT generated the reset, if so, go straight to app
 602:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 603:stk500boot.c  **** 	{
 604:stk500boot.c  **** 		app_start();
 605:stk500boot.c  **** 	}
 606:stk500boot.c  **** 	//************************************************************************
 607:stk500boot.c  **** #endif
 608:stk500boot.c  **** 
 609:stk500boot.c  **** 
 610:stk500boot.c  **** 	boot_timer	=	0;
 611:stk500boot.c  **** 	boot_state	=	0;
 612:stk500boot.c  **** 
 613:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 614:stk500boot.c  **** 	boot_timeout	=	 90000;		//*	should be about 4 seconds
 615:stk500boot.c  **** //	boot_timeout	=	170000;
 616:stk500boot.c  **** //	boot_timeout	=	 20000;		//*	should be about 1 second
 617:stk500boot.c  **** #else
 618:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 619:stk500boot.c  **** #endif
 620:stk500boot.c  **** 	/*
 621:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 622:stk500boot.c  **** 	 */
 623:stk500boot.c  **** 
 624:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 625:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 626:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 627:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 628:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 629:stk500boot.c  **** 
 630:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 631:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 632:stk500boot.c  **** 	{
 633:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 634:stk500boot.c  **** 		delay_ms(100);
 635:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 636:stk500boot.c  **** 		delay_ms(100);
 637:stk500boot.c  **** 	}
 638:stk500boot.c  **** #endif
 639:stk500boot.c  **** 
 640:stk500boot.c  **** #endif
 641:stk500boot.c  **** 	/*
 642:stk500boot.c  **** 	 * Init UART
 643:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 644:stk500boot.c  **** 	 */
 645:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 646:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 647:stk500boot.c  **** #endif
 648:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 649:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 650:stk500boot.c  **** 
 651:stk500boot.c  **** #if defined(_BOARD_MESHTHING_2564RFR2_)
 652:stk500boot.c  **** /*
 653:stk500boot.c  **** 	UCSR1A &= ~(1 << U2X1);
 654:stk500boot.c  **** 	UART_CONTROL_REG  |=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 655:stk500boot.c  **** 	UBRR1H = (UART_BAUD_SELECT(BAUDRATE,F_CPU)>>8);
 656:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 657:stk500boot.c  **** 
 658:stk500boot.c  **** 	UCSR1C |= (0 << USBS1) | (1 << UCSZ10) | (1 << UCSZ11);	
 659:stk500boot.c  **** */
 660:stk500boot.c  **** 
 661:stk500boot.c  **** 	#  define UCSRA UCSR0A
 662:stk500boot.c  **** 	#  define UDRE  UDRE0
 663:stk500boot.c  **** 	#  define UCSRB UCSR0B
 664:stk500boot.c  **** 	#  define RXEN  RXEN0
 665:stk500boot.c  **** 	#  define TXEN  TXEN0
 666:stk500boot.c  **** 	#  define UCSRC UCSR0C
 667:stk500boot.c  **** 
 668:stk500boot.c  **** 	#  define UBRR UBRR0L
 669:stk500boot.c  **** 	#  define UDR UDR0
 670:stk500boot.c  **** 
 671:stk500boot.c  **** 	#define BAUDRATE 115200
 672:stk500boot.c  **** //	#define BAUD_PRESCALE (F_CPU / 16 / BAUDRATE -1)   
 673:stk500boot.c  **** 
 674:stk500boot.c  **** //trying double speed as it has less error at 115200...
 675:stk500boot.c  **** 	#define BAUD_PRESCALE (F_CPU / 8 / BAUDRATE -1)   
 676:stk500boot.c  **** 	UCSRA |= 1 << U2X0;	
 677:stk500boot.c  **** 
 678:stk500boot.c  **** 	// Clear double speed operation
 679:stk500boot.c  **** 	//UCSRA &= ~(1 << U2X1);
 680:stk500boot.c  **** 
 681:stk500boot.c  **** 	// Enable TX and RX circuitry
 682:stk500boot.c  ****   	UCSRB |= (1 << RXEN) | (1 << TXEN);
 683:stk500boot.c  **** 
 684:stk500boot.c  **** 	// 8-bit data, 1 stop bit
 685:stk500boot.c  ****   	UCSRC |= (0 << USBS1) | (1 << UCSZ10) | (1 << UCSZ11);
 686:stk500boot.c  **** 
 687:stk500boot.c  **** 	// Initialize baud rate
 688:stk500boot.c  ****   	UBRR0H = (BAUD_PRESCALE >> 8);
 689:stk500boot.c  ****   	UBRR0L =  BAUD_PRESCALE;
 690:stk500boot.c  **** 
 691:stk500boot.c  **** #endif
 692:stk500boot.c  **** 
 693:stk500boot.c  **** 
 694:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 695:stk500boot.c  **** 
 696:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 697:stk500boot.c  **** //	delay_ms(500);
 698:stk500boot.c  **** 
 699:stk500boot.c  **** 	sendchar('s');
 700:stk500boot.c  **** 	sendchar('t');
 701:stk500boot.c  **** 	sendchar('k');
 702:stk500boot.c  **** //	sendchar('5');
 703:stk500boot.c  **** //	sendchar('0');
 704:stk500boot.c  **** //	sendchar('0');
 705:stk500boot.c  **** 	sendchar('v');
 706:stk500boot.c  **** 	sendchar('2');
 707:stk500boot.c  **** 	sendchar(0x0d);
 708:stk500boot.c  **** 	sendchar(0x0a);
 709:stk500boot.c  **** 
 710:stk500boot.c  **** 	delay_ms(100);
 711:stk500boot.c  **** #endif
 712:stk500boot.c  **** 
 713:stk500boot.c  **** 	while (boot_state==0)
 714:stk500boot.c  **** 	{
 715:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 716:stk500boot.c  **** 		{
 717:stk500boot.c  **** 			_delay_ms(0.001);
 718:stk500boot.c  **** 			boot_timer++;
 719:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 720:stk500boot.c  **** 			{
 721:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 722:stk500boot.c  **** 			}
 723:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 724:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 725:stk500boot.c  **** 			{
 726:stk500boot.c  **** 	
 727:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 728:stk500boot.c  **** 				sendchar('b');
 729:stk500boot.c  **** #endif
 730:stk500boot.c  **** 			//*	toggle the LED
 731:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 732:stk500boot.c  **** 			}
 733:stk500boot.c  **** 		#endif
 734:stk500boot.c  **** 		}
 735:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 736:stk500boot.c  **** 	}
 737:stk500boot.c  **** 
 738:stk500boot.c  **** 
 739:stk500boot.c  **** 	if (boot_state==1)
 740:stk500boot.c  **** 	{
 741:stk500boot.c  **** 		//*	main loop
 742:stk500boot.c  **** //		sendchar('m');
 743:stk500boot.c  **** 		while (!isLeave)
 744:stk500boot.c  **** 		{
 745:stk500boot.c  **** 			/*
 746:stk500boot.c  **** 			 * Collect received bytes to a complete message
 747:stk500boot.c  **** 			 */
 748:stk500boot.c  **** 			msgParseState	=	ST_START;
 749:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 750:stk500boot.c  **** 			{
 751:stk500boot.c  **** //				sendchar('w');
 752:stk500boot.c  **** 				if (boot_state==1)
 753:stk500boot.c  **** 				{
 754:stk500boot.c  **** 					boot_state	=	0;
 755:stk500boot.c  **** 					c			=	UART_DATA_REG;
 756:stk500boot.c  **** 				}
 757:stk500boot.c  **** 				else
 758:stk500boot.c  **** 				{
 759:stk500boot.c  **** 				//	c	=	recchar();
 760:stk500boot.c  **** 					c	=	recchar_timeout();
 761:stk500boot.c  **** 					
 762:stk500boot.c  **** 				}
 763:stk500boot.c  **** 
 764:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 765:stk500boot.c  **** 				rcvdCharCntr++;
 766:stk500boot.c  **** 
 767:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 768:stk500boot.c  **** 				{
 769:stk500boot.c  **** 					exPointCntr++;
 770:stk500boot.c  **** 					if (exPointCntr == 3)
 771:stk500boot.c  **** 					{
 772:stk500boot.c  **** 						RunMonitor();
 773:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 774:stk500boot.c  **** 						isLeave			=	1;
 775:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 776:stk500boot.c  **** 						break;
 777:stk500boot.c  **** 					}
 778:stk500boot.c  **** 				}
 779:stk500boot.c  **** 				else
 780:stk500boot.c  **** 				{
 781:stk500boot.c  **** 					exPointCntr	=	0;
 782:stk500boot.c  **** 				}
 783:stk500boot.c  **** 			#endif
 784:stk500boot.c  **** 
 785:stk500boot.c  **** 				switch (msgParseState)
 786:stk500boot.c  **** 				{
 787:stk500boot.c  **** 					case ST_START:
 788:stk500boot.c  **** 						if ( c == MESSAGE_START )
 789:stk500boot.c  **** 						{
 790:stk500boot.c  **** //								sendchar('0');
 791:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 792:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 793:stk500boot.c  **** 						}
 794:stk500boot.c  **** 						break;
 795:stk500boot.c  **** 
 796:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 797:stk500boot.c  **** //								sendchar('1');
 798:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 799:stk500boot.c  **** 						seqNum			=	c;
 800:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 801:stk500boot.c  **** 						checksum		^=	c;
 802:stk500boot.c  **** 					#else
 803:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 804:stk500boot.c  **** 						{
 805:stk500boot.c  **** 							seqNum			=	c;
 806:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 807:stk500boot.c  **** 							checksum		^=	c;
 808:stk500boot.c  **** 						}
 809:stk500boot.c  **** 						else
 810:stk500boot.c  **** 						{
 811:stk500boot.c  **** 							msgParseState	=	ST_START;
 812:stk500boot.c  **** 						}
 813:stk500boot.c  **** 					#endif
 814:stk500boot.c  **** 						break;
 815:stk500boot.c  **** 
 816:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 817:stk500boot.c  **** 						msgLength		=	c<<8;
 818:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 819:stk500boot.c  **** 						checksum		^=	c;
 820:stk500boot.c  **** 						break;
 821:stk500boot.c  **** 
 822:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 823:stk500boot.c  **** 						msgLength		|=	c;
 824:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 825:stk500boot.c  **** 						checksum		^=	c;
 826:stk500boot.c  **** 						break;
 827:stk500boot.c  **** 
 828:stk500boot.c  **** 					case ST_GET_TOKEN:
 829:stk500boot.c  **** 						if ( c == TOKEN )
 830:stk500boot.c  **** 						{
 831:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 832:stk500boot.c  **** 							checksum		^=	c;
 833:stk500boot.c  **** 							ii				=	0;
 834:stk500boot.c  **** 						}
 835:stk500boot.c  **** 						else
 836:stk500boot.c  **** 						{
 837:stk500boot.c  **** 							msgParseState	=	ST_START;
 838:stk500boot.c  **** 						}
 839:stk500boot.c  **** 						break;
 840:stk500boot.c  **** 
 841:stk500boot.c  **** 					case ST_GET_DATA:
 842:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 843:stk500boot.c  **** 						checksum		^=	c;
 844:stk500boot.c  **** 						if (ii == msgLength )
 845:stk500boot.c  **** 						{
 846:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 847:stk500boot.c  **** 						}
 848:stk500boot.c  **** 						break;
 849:stk500boot.c  **** 
 850:stk500boot.c  **** 					case ST_GET_CHECK:
 851:stk500boot.c  **** 						if ( c == checksum )
 852:stk500boot.c  **** 						{
 853:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 854:stk500boot.c  **** 						}
 855:stk500boot.c  **** 						else
 856:stk500boot.c  **** 						{
 857:stk500boot.c  **** 							msgParseState	=	ST_START;
 858:stk500boot.c  **** 						}
 859:stk500boot.c  **** 						break;
 860:stk500boot.c  **** 				}	//	switch
 861:stk500boot.c  **** 			}	//	while(msgParseState)
 862:stk500boot.c  **** 
 863:stk500boot.c  **** 			/*
 864:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 865:stk500boot.c  **** 			 */
 866:stk500boot.c  **** 
 867:stk500boot.c  **** 			switch (msgBuffer[0])
 868:stk500boot.c  **** 			{
 869:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 870:stk500boot.c  **** 				case CMD_SPI_MULTI:
 871:stk500boot.c  **** 					{
 872:stk500boot.c  **** 						unsigned char answerByte;
 873:stk500boot.c  **** 						unsigned char flag=0;
 874:stk500boot.c  **** 
 875:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 876:stk500boot.c  **** 						{
 877:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 878:stk500boot.c  **** 
 879:stk500boot.c  **** 							if ( signatureIndex == 0 )
 880:stk500boot.c  **** 							{
 881:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 882:stk500boot.c  **** 							}
 883:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 884:stk500boot.c  **** 							{
 885:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 886:stk500boot.c  **** 							}
 887:stk500boot.c  **** 							else
 888:stk500boot.c  **** 							{
 889:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 890:stk500boot.c  **** 							}
 891:stk500boot.c  **** 						}
 892:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 893:stk500boot.c  **** 						{
 894:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 895:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 896:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 897:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 898:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 899:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 900:stk500boot.c  **** 							{
 901:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 902:stk500boot.c  **** 							}
 903:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 904:stk500boot.c  **** 							{
 905:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 906:stk500boot.c  **** 							}
 907:stk500boot.c  **** 							else
 908:stk500boot.c  **** 							{
 909:stk500boot.c  **** 								answerByte	=	0;
 910:stk500boot.c  **** 							}
 911:stk500boot.c  **** 						}
 912:stk500boot.c  **** 						else
 913:stk500boot.c  **** 						{
 914:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 915:stk500boot.c  **** 						}
 916:stk500boot.c  **** 						if ( !flag )
 917:stk500boot.c  **** 						{
 918:stk500boot.c  **** 							msgLength		=	7;
 919:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 920:stk500boot.c  **** 							msgBuffer[2]	=	0;
 921:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 922:stk500boot.c  **** 							msgBuffer[4]	=	0;
 923:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 924:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 925:stk500boot.c  **** 						}
 926:stk500boot.c  **** 					}
 927:stk500boot.c  **** 					break;
 928:stk500boot.c  **** 	#endif
 929:stk500boot.c  **** 				case CMD_SIGN_ON:
 930:stk500boot.c  **** 					msgLength		=	11;
 931:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 932:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 933:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 934:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 935:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 936:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 937:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 938:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 939:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 940:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 941:stk500boot.c  **** 					break;
 942:stk500boot.c  **** 
 943:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 944:stk500boot.c  **** 					{
 945:stk500boot.c  **** 						unsigned char value;
 946:stk500boot.c  **** 
 947:stk500boot.c  **** 						switch(msgBuffer[1])
 948:stk500boot.c  **** 						{
 949:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 950:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 951:stk500boot.c  **** 							break;
 952:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 953:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 954:stk500boot.c  **** 							break;
 955:stk500boot.c  **** 						case PARAM_HW_VER:
 956:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 957:stk500boot.c  **** 							break;
 958:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 959:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 960:stk500boot.c  **** 							break;
 961:stk500boot.c  **** 						case PARAM_SW_MINOR:
 962:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 963:stk500boot.c  **** 							break;
 964:stk500boot.c  **** 						default:
 965:stk500boot.c  **** 							value	=	0;
 966:stk500boot.c  **** 							break;
 967:stk500boot.c  **** 						}
 968:stk500boot.c  **** 						msgLength		=	3;
 969:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 970:stk500boot.c  **** 						msgBuffer[2]	=	value;
 971:stk500boot.c  **** 					}
 972:stk500boot.c  **** 					break;
 973:stk500boot.c  **** 
 974:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 975:stk500boot.c  **** 					isLeave	=	1;
 976:stk500boot.c  **** 					//*	fall thru
 977:stk500boot.c  **** 
 978:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 979:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 980:stk500boot.c  **** 					msgLength		=	2;
 981:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 982:stk500boot.c  **** 					break;
 983:stk500boot.c  **** 
 984:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 985:stk500boot.c  **** 					{
 986:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 987:stk500boot.c  **** 						unsigned char signature;
 988:stk500boot.c  **** 
 989:stk500boot.c  **** 						if ( signatureIndex == 0 )
 990:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 991:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 992:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 993:stk500boot.c  **** 						else
 994:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 995:stk500boot.c  **** 
 996:stk500boot.c  **** 						msgLength		=	4;
 997:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 998:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 999:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1000:stk500boot.c  **** 					}
1001:stk500boot.c  **** 					break;
1002:stk500boot.c  **** 
1003:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
1004:stk500boot.c  **** 					msgLength		=	4;
1005:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1006:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
1007:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
1008:stk500boot.c  **** 					break;
1009:stk500boot.c  **** 
1010:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
1011:stk500boot.c  **** 					{
1012:stk500boot.c  **** 						unsigned char fuseBits;
1013:stk500boot.c  **** 
1014:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
1015:stk500boot.c  **** 						{
1016:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
1017:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
1018:stk500boot.c  **** 							else
1019:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
1020:stk500boot.c  **** 						}
1021:stk500boot.c  **** 						else
1022:stk500boot.c  **** 						{
1023:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
1024:stk500boot.c  **** 						}
1025:stk500boot.c  **** 						msgLength		=	4;
1026:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1027:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
1028:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
1029:stk500boot.c  **** 					}
1030:stk500boot.c  **** 					break;
1031:stk500boot.c  **** 
1032:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
1033:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
1034:stk500boot.c  **** 					{
1035:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
1036:stk500boot.c  **** 
1037:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
1038:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
1039:stk500boot.c  **** 						boot_spm_busy_wait();
1040:stk500boot.c  **** 
1041:stk500boot.c  **** 						msgLength		=	3;
1042:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1043:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
1044:stk500boot.c  **** 					}
1045:stk500boot.c  **** 					break;
1046:stk500boot.c  **** 	#endif
1047:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
1048:stk500boot.c  **** 					eraseAddress	=	0;
1049:stk500boot.c  **** 					msgLength		=	2;
1050:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
1051:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
1052:stk500boot.c  **** 					break;
1053:stk500boot.c  **** 
1054:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
1055:stk500boot.c  **** 	#if defined(RAMPZ)
1056:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
1057:stk500boot.c  **** 	#else
1058:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
1059:stk500boot.c  **** 	#endif
1060:stk500boot.c  **** 					msgLength		=	2;
1061:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
1062:stk500boot.c  **** 					break;
1063:stk500boot.c  **** 
1064:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
1065:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
1066:stk500boot.c  **** 					{
1067:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1068:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
1069:stk500boot.c  **** 						unsigned int	data;
1070:stk500boot.c  **** 						unsigned char	highByte, lowByte;
1071:stk500boot.c  **** 						address_t		tempaddress	=	address;
1072:stk500boot.c  **** 
1073:stk500boot.c  **** 
1074:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
1075:stk500boot.c  **** 						{
1076:stk500boot.c  **** 							// erase only main section (bootloader protection)
1077:stk500boot.c  **** 							if (eraseAddress < APP_END )
1078:stk500boot.c  **** 							{
1079:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
1080:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
1081:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
1082:stk500boot.c  **** 							}
1083:stk500boot.c  **** 
1084:stk500boot.c  **** 							/* Write FLASH */
1085:stk500boot.c  **** 							do {
1086:stk500boot.c  **** 								lowByte		=	*p++;
1087:stk500boot.c  **** 								highByte 	=	*p++;
1088:stk500boot.c  **** 
1089:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
1090:stk500boot.c  **** 								boot_page_fill(address,data);
1091:stk500boot.c  **** 
1092:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
1093:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1094:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1095:stk500boot.c  **** 
1096:stk500boot.c  **** 							boot_page_write(tempaddress);
1097:stk500boot.c  **** 							boot_spm_busy_wait();
1098:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1099:stk500boot.c  **** 						}
1100:stk500boot.c  **** 						else
1101:stk500boot.c  **** 						{
1102:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1103:stk500boot.c  **** 							uint16_t ii = address >> 1;
1104:stk500boot.c  **** 							/* write EEPROM */
1105:stk500boot.c  **** 							while (size) {
1106:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1107:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1108:stk500boot.c  **** 								ii++;
1109:stk500boot.c  **** 								size--;
1110:stk500boot.c  **** 							}
1111:stk500boot.c  **** 						}
1112:stk500boot.c  **** 						msgLength		=	2;
1113:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1114:stk500boot.c  **** 					}
1115:stk500boot.c  **** 					break;
1116:stk500boot.c  **** 
1117:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1118:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1119:stk500boot.c  **** 					{
1120:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1121:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1122:stk500boot.c  **** 						msgLength				=	size+3;
1123:stk500boot.c  **** 
1124:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1125:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1126:stk500boot.c  **** 						{
1127:stk500boot.c  **** 							unsigned int data;
1128:stk500boot.c  **** 
1129:stk500boot.c  **** 							// Read FLASH
1130:stk500boot.c  **** 							do {
1131:stk500boot.c  **** 						//#if defined(RAMPZ)
1132:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1133:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1134:stk500boot.c  **** 						#else
1135:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1136:stk500boot.c  **** 						#endif
1137:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1138:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1139:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1140:stk500boot.c  **** 								size	-=	2;
1141:stk500boot.c  **** 							}while (size);
1142:stk500boot.c  **** 						}
1143:stk500boot.c  **** 						else
1144:stk500boot.c  **** 						{
1145:stk500boot.c  **** 							/* Read EEPROM */
1146:stk500boot.c  **** 							do {
1147:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1148:stk500boot.c  **** 								EEARH	=	((address >> 8));
1149:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1150:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1151:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1152:stk500boot.c  **** 								size--;
1153:stk500boot.c  **** 							} while (size);
1154:stk500boot.c  **** 						}
1155:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1156:stk500boot.c  **** 					}
1157:stk500boot.c  **** 					break;
1158:stk500boot.c  **** 
1159:stk500boot.c  **** 				default:
1160:stk500boot.c  **** 					msgLength		=	2;
1161:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1162:stk500boot.c  **** 					break;
1163:stk500boot.c  **** 			}
1164:stk500boot.c  **** 
1165:stk500boot.c  **** 			/*
1166:stk500boot.c  **** 			 * Now send answer message back
1167:stk500boot.c  **** 			 */
1168:stk500boot.c  **** 			sendchar(MESSAGE_START);
1169:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1170:stk500boot.c  **** 
1171:stk500boot.c  **** 			sendchar(seqNum);
1172:stk500boot.c  **** 			checksum	^=	seqNum;
1173:stk500boot.c  **** 
1174:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1175:stk500boot.c  **** 			sendchar(c);
1176:stk500boot.c  **** 			checksum	^=	c;
1177:stk500boot.c  **** 
1178:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1179:stk500boot.c  **** 			sendchar(c);
1180:stk500boot.c  **** 			checksum ^= c;
1181:stk500boot.c  **** 
1182:stk500boot.c  **** 			sendchar(TOKEN);
1183:stk500boot.c  **** 			checksum ^= TOKEN;
1184:stk500boot.c  **** 
1185:stk500boot.c  **** 			p	=	msgBuffer;
1186:stk500boot.c  **** 			while ( msgLength )
1187:stk500boot.c  **** 			{
1188:stk500boot.c  **** 				c	=	*p++;
1189:stk500boot.c  **** 				sendchar(c);
1190:stk500boot.c  **** 				checksum ^=c;
1191:stk500boot.c  **** 				msgLength--;
1192:stk500boot.c  **** 			}
1193:stk500boot.c  **** 			sendchar(checksum);
1194:stk500boot.c  **** 			seqNum++;
1195:stk500boot.c  **** 	
1196:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1197:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1198:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1199:stk500boot.c  **** 		#endif
1200:stk500boot.c  **** 
1201:stk500boot.c  **** 		}
1202:stk500boot.c  **** 	}
1203:stk500boot.c  **** 
1204:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1205:stk500boot.c  **** 	//*	this is for debugging it can be removed
1206:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1207:stk500boot.c  **** 	{
1208:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1209:stk500boot.c  **** 		delay_ms(200);
1210:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1211:stk500boot.c  **** 		delay_ms(200);
1212:stk500boot.c  **** 	}
1213:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1214:stk500boot.c  **** #endif
1215:stk500boot.c  **** 
1216:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1217:stk500boot.c  **** 	sendchar('j');
1218:stk500boot.c  **** //	sendchar('u');
1219:stk500boot.c  **** //	sendchar('m');
1220:stk500boot.c  **** //	sendchar('p');
1221:stk500boot.c  **** //	sendchar(' ');
1222:stk500boot.c  **** //	sendchar('u');
1223:stk500boot.c  **** //	sendchar('s');
1224:stk500boot.c  **** //	sendchar('r');
1225:stk500boot.c  **** 	sendchar(0x0d);
1226:stk500boot.c  **** 	sendchar(0x0a);
1227:stk500boot.c  **** 
1228:stk500boot.c  **** 	delay_ms(100);
1229:stk500boot.c  **** #endif
1230:stk500boot.c  **** 
1231:stk500boot.c  **** 
1232:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1233:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1234:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1235:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1236:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1237:stk500boot.c  **** #endif
1238:stk500boot.c  **** 
1239:stk500boot.c  **** 
1240:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1241:stk500boot.c  **** 
1242:stk500boot.c  **** 	/*
1243:stk500boot.c  **** 	 * Now leave bootloader
1244:stk500boot.c  **** 	 */
1245:stk500boot.c  **** 
1246:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1247:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1248:stk500boot.c  **** 
1249:stk500boot.c  **** 
1250:stk500boot.c  **** 	asm volatile(
1251:stk500boot.c  **** 			"clr	r30		\n\t"
1252:stk500boot.c  **** 			"clr	r31		\n\t"
1253:stk500boot.c  **** 			"ijmp	\n\t"
1254:stk500boot.c  **** 			);
1255:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1256:stk500boot.c  **** //					"push r1" "\n\t"
1257:stk500boot.c  **** //					"ret"	 "\n\t"
1258:stk500boot.c  **** //					::);
1259:stk500boot.c  **** 
1260:stk500boot.c  **** 	 /*
1261:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1262:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1263:stk500boot.c  **** 	 * understand this
1264:stk500boot.c  **** 	 */
1265:stk500boot.c  **** 	for(;;);
1266:stk500boot.c  **** }
1267:stk500boot.c  **** 
1268:stk500boot.c  **** /*
1269:stk500boot.c  **** base address = f800
1270:stk500boot.c  **** 
1271:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1272:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1273:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1274:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1275:stk500boot.c  **** avrdude>
1276:stk500boot.c  **** 
1277:stk500boot.c  **** 
1278:stk500boot.c  **** base address = f000
1279:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1280:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1281:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1282:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1283:stk500boot.c  **** avrdude>
1284:stk500boot.c  **** */
1285:stk500boot.c  **** 
1286:stk500boot.c  **** //************************************************************************
1287:stk500boot.c  **** #ifdef ENABLE_MONITOR
1288:stk500boot.c  **** #include	<math.h>
1289:stk500boot.c  **** 
1290:stk500boot.c  **** unsigned long	gRamIndex;
1291:stk500boot.c  **** unsigned long	gFlashIndex;
1292:stk500boot.c  **** unsigned long	gEepromIndex;
1293:stk500boot.c  **** 
1294:stk500boot.c  **** 
1295:stk500boot.c  **** #define	true	1
1296:stk500boot.c  **** #define	false	0
1297:stk500boot.c  **** 
1298:stk500boot.c  **** #include	"avr_cpunames.h"
1299:stk500boot.c  **** 
1300:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1301:stk500boot.c  **** 	#error cpu name not defined
1302:stk500boot.c  **** #endif
1303:stk500boot.c  **** 
1304:stk500boot.c  **** #ifdef _VECTORS_SIZE
1305:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1306:stk500boot.c  **** #else
1307:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1308:stk500boot.c  **** #endif
1309:stk500boot.c  **** 
1310:stk500boot.c  **** 
1311:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1312:stk500boot.c  **** 
1313:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1314:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1315:stk500boot.c  **** #else
1316:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1317:stk500boot.c  **** #endif
1318:stk500boot.c  **** 
1319:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1320:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1321:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1322:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1323:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1324:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1325:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1326:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1327:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1328:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1329:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1330:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1331:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1332:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1333:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1334:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1335:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1336:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1337:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1338:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1339:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1340:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1341:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1342:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1343:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1344:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1345:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1346:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1347:stk500boot.c  **** 
1348:stk500boot.c  **** 
1349:stk500boot.c  **** //************************************************************************
1350:stk500boot.c  **** //*	Help messages
1351:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1352:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1353:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1354:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1355:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1356:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1357:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1358:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1359:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1360:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1361:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1362:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1363:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1364:stk500boot.c  **** 
1365:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1366:stk500boot.c  **** 
1367:stk500boot.c  **** 
1368:stk500boot.c  **** //************************************************************************
1369:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1370:stk500boot.c  **** {
 159               		.loc 1 1370 0
 160               		.cfi_startproc
 161               	.LVL5:
 162 0036 CF93      		push r28
 163               	.LCFI0:
 164               		.cfi_def_cfa_offset 4
 165               		.cfi_offset 28, -3
 166 0038 DF93      		push r29
 167               	.LCFI1:
 168               		.cfi_def_cfa_offset 5
 169               		.cfi_offset 29, -4
 170               	/* prologue: function */
 171               	/* frame size = 0 */
 172               	/* stack size = 2 */
 173               	.L__stack_usage = 2
1371:stk500boot.c  **** char	theChar;
1372:stk500boot.c  **** 
1373:stk500boot.c  **** 	dataPtr		+=	offset;
 174               		.loc 1 1373 0
 175 003a EC01      		movw r28,r24
 176 003c C60F      		add r28,r22
 177 003e D11D      		adc r29,__zero_reg__
 178               	.LVL6:
 179               	.L16:
 180               	.LBB45:
1374:stk500boot.c  **** 
1375:stk500boot.c  **** 	do {
1376:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1377:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 181               		.loc 1 1377 0
 182 0040 AE01      		movw r20,r28
 183 0042 60E0      		ldi r22,0
 184 0044 70E0      		ldi r23,0
 185               	/* #APP */
 186               	 ;  1377 "stk500boot.c" 1
 187 0046 6BBF      		out 59, r22
 188 0048 FA01      		movw r30, r20
 189 004a 8791      		elpm r24, Z+
 190               		
 191               	 ;  0 "" 2
 192               	.LVL7:
 193               	/* #NOAPP */
 194               	.LBE45:
1378:stk500boot.c  **** 	#else
1379:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1380:stk500boot.c  **** 	#endif
1381:stk500boot.c  **** 		if (theChar != 0)
 195               		.loc 1 1381 0
 196 004c 8823      		tst r24
 197 004e 01F0      		breq .L14
 198               	.LVL8:
 199               	.LBB46:
1377:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 200               		.loc 1 1377 0
 201 0050 2196      		adiw r28,1
 202               	.LVL9:
 203               	.LBE46:
1382:stk500boot.c  **** 		{
1383:stk500boot.c  **** 			sendchar(theChar);
 204               		.loc 1 1383 0
 205 0052 0E94 0000 		call sendchar
 206               	.LVL10:
 207 0056 00C0      		rjmp .L16
 208               	.LVL11:
 209               	.L14:
 210               	/* epilogue start */
1384:stk500boot.c  **** 		}
1385:stk500boot.c  **** 	} while (theChar != 0);
1386:stk500boot.c  **** }
 211               		.loc 1 1386 0
 212 0058 DF91      		pop r29
 213 005a CF91      		pop r28
 214 005c 0895      		ret
 215               		.cfi_endproc
 216               	.LFE14:
 218               	.global	PrintNewLine
 220               	PrintNewLine:
 221               	.LFB15:
1387:stk500boot.c  **** 
1388:stk500boot.c  **** //************************************************************************
1389:stk500boot.c  **** void	PrintNewLine(void)
1390:stk500boot.c  **** {
 222               		.loc 1 1390 0
 223               		.cfi_startproc
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
1391:stk500boot.c  **** 	sendchar(0x0d);
 228               		.loc 1 1391 0
 229 005e 8DE0      		ldi r24,lo8(13)
 230 0060 0E94 0000 		call sendchar
 231               	.LVL12:
1392:stk500boot.c  **** 	sendchar(0x0a);
 232               		.loc 1 1392 0
 233 0064 8AE0      		ldi r24,lo8(10)
 234 0066 0C94 0000 		jmp sendchar
 235               	.LVL13:
 236               		.cfi_endproc
 237               	.LFE15:
 239               		.section	.text.unlikely
 241               	PrintAvailablePort:
 242               	.LFB25:
1393:stk500boot.c  **** }
1394:stk500boot.c  **** 
1395:stk500boot.c  **** 
1396:stk500boot.c  **** //************************************************************************
1397:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1398:stk500boot.c  **** {
1399:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1400:stk500boot.c  **** 
1401:stk500boot.c  **** 	PrintNewLine();
1402:stk500boot.c  **** }
1403:stk500boot.c  **** 
1404:stk500boot.c  **** 
1405:stk500boot.c  **** //************************************************************************
1406:stk500boot.c  **** void	PrintString(char *textString)
1407:stk500boot.c  **** {
1408:stk500boot.c  **** char	theChar;
1409:stk500boot.c  **** int		ii;
1410:stk500boot.c  **** 
1411:stk500boot.c  **** 	theChar		=	1;
1412:stk500boot.c  **** 	ii			=	0;
1413:stk500boot.c  **** 	while (theChar != 0)
1414:stk500boot.c  **** 	{
1415:stk500boot.c  **** 		theChar	=	textString[ii];
1416:stk500boot.c  **** 		if (theChar != 0)
1417:stk500boot.c  **** 		{
1418:stk500boot.c  **** 			sendchar(theChar);
1419:stk500boot.c  **** 		}
1420:stk500boot.c  **** 		ii++;
1421:stk500boot.c  **** 	}
1422:stk500boot.c  **** }
1423:stk500boot.c  **** 
1424:stk500boot.c  **** //************************************************************************
1425:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1426:stk500boot.c  **** {
1427:stk500boot.c  **** char	theChar;
1428:stk500boot.c  **** 
1429:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1430:stk500boot.c  **** 	if (theChar > 0x39)
1431:stk500boot.c  **** 	{
1432:stk500boot.c  **** 		theChar	+=	7;
1433:stk500boot.c  **** 	}
1434:stk500boot.c  **** 	sendchar(theChar );
1435:stk500boot.c  **** 
1436:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1437:stk500boot.c  **** 	if (theChar > 0x39)
1438:stk500boot.c  **** 	{
1439:stk500boot.c  **** 		theChar	+=	7;
1440:stk500boot.c  **** 	}
1441:stk500boot.c  **** 	sendchar(theChar );
1442:stk500boot.c  **** }
1443:stk500boot.c  **** 
1444:stk500boot.c  **** //************************************************************************
1445:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1446:stk500boot.c  **** {
1447:stk500boot.c  **** int	theChar;
1448:stk500boot.c  **** int	myNumber;
1449:stk500boot.c  **** 
1450:stk500boot.c  **** 	myNumber	=	theNumber;
1451:stk500boot.c  **** 
1452:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1453:stk500boot.c  **** 	{
1454:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1455:stk500boot.c  **** 		sendchar(theChar );
1456:stk500boot.c  **** 	}
1457:stk500boot.c  **** 
1458:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1459:stk500boot.c  **** 	{
1460:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1461:stk500boot.c  **** 		sendchar(theChar );
1462:stk500boot.c  **** 	}
1463:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1464:stk500boot.c  **** 	sendchar(theChar );
1465:stk500boot.c  **** }
1466:stk500boot.c  **** 
1467:stk500boot.c  **** 
1468:stk500boot.c  **** 
1469:stk500boot.c  **** 
1470:stk500boot.c  **** //************************************************************************
1471:stk500boot.c  **** static void	PrintCPUstats(void)
1472:stk500boot.c  **** {
1473:stk500boot.c  **** unsigned char fuseByte;
1474:stk500boot.c  **** 
1475:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1476:stk500boot.c  **** 
1477:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1478:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1479:stk500boot.c  **** 
1480:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1481:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1482:stk500boot.c  **** 
1483:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1484:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1485:stk500boot.c  **** 	PrintNewLine();
1486:stk500boot.c  **** 
1487:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1488:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1489:stk500boot.c  **** 
1490:stk500boot.c  **** 	//*	these can be found in avr/version.h
1491:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1492:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1493:stk500boot.c  **** 
1494:stk500boot.c  **** #if defined(SIGNATURE_0)
1495:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1496:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1497:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1498:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1499:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1500:stk500boot.c  **** 	PrintNewLine();
1501:stk500boot.c  **** #endif
1502:stk500boot.c  **** 
1503:stk500boot.c  **** 
1504:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1505:stk500boot.c  **** 	//*	fuse settings
1506:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1507:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1508:stk500boot.c  **** 	PrintHexByte(fuseByte);
1509:stk500boot.c  **** 	PrintNewLine();
1510:stk500boot.c  **** 
1511:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1512:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1513:stk500boot.c  **** 	PrintHexByte(fuseByte);
1514:stk500boot.c  **** 	PrintNewLine();
1515:stk500boot.c  **** 
1516:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1517:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1518:stk500boot.c  **** 	PrintHexByte(fuseByte);
1519:stk500boot.c  **** 	PrintNewLine();
1520:stk500boot.c  **** 
1521:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1522:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1523:stk500boot.c  **** 	PrintHexByte(fuseByte);
1524:stk500boot.c  **** 	PrintNewLine();
1525:stk500boot.c  **** 
1526:stk500boot.c  **** #endif
1527:stk500boot.c  **** 
1528:stk500boot.c  **** }
1529:stk500boot.c  **** 
1530:stk500boot.c  **** 
1531:stk500boot.c  **** //************************************************************************
1532:stk500boot.c  **** static void BlinkLED(void)
1533:stk500boot.c  **** {
1534:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1535:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1536:stk500boot.c  **** 
1537:stk500boot.c  **** 	while (!Serial_Available())
1538:stk500boot.c  **** 	{
1539:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1540:stk500boot.c  **** 		delay_ms(100);
1541:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1542:stk500boot.c  **** 		delay_ms(100);
1543:stk500boot.c  **** 	}
1544:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1545:stk500boot.c  **** }
1546:stk500boot.c  **** 
1547:stk500boot.c  **** enum
1548:stk500boot.c  **** {
1549:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1550:stk500boot.c  **** 	kDUMP_EEPROM,
1551:stk500boot.c  **** 	kDUMP_RAM
1552:stk500boot.c  **** };
1553:stk500boot.c  **** 
1554:stk500boot.c  **** //************************************************************************
1555:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1556:stk500boot.c  **** {
1557:stk500boot.c  **** unsigned long	myAddressPointer;
1558:stk500boot.c  **** uint8_t			ii;
1559:stk500boot.c  **** unsigned char	theValue;
1560:stk500boot.c  **** char			asciiDump[18];
1561:stk500boot.c  **** unsigned char	*ramPtr;
1562:stk500boot.c  **** 
1563:stk500boot.c  **** 
1564:stk500boot.c  **** 	ramPtr				=	0;
1565:stk500boot.c  **** 	theValue			=	0;
1566:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1567:stk500boot.c  **** 	while (numRows > 0)
1568:stk500boot.c  **** 	{
1569:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1570:stk500boot.c  **** 		{
1571:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1572:stk500boot.c  **** 		}
1573:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1574:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1575:stk500boot.c  **** 		sendchar(0x20);
1576:stk500boot.c  **** 		sendchar('-');
1577:stk500boot.c  **** 		sendchar(0x20);
1578:stk500boot.c  **** 
1579:stk500boot.c  **** 		asciiDump[0]		=	0;
1580:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1581:stk500boot.c  **** 		{
1582:stk500boot.c  **** 			switch(dumpWhat)
1583:stk500boot.c  **** 			{
1584:stk500boot.c  **** 				case kDUMP_FLASH:
1585:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1586:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1587:stk500boot.c  **** 				#else
1588:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1589:stk500boot.c  **** 				#endif
1590:stk500boot.c  **** 					break;
1591:stk500boot.c  **** 
1592:stk500boot.c  **** 				case kDUMP_EEPROM:
1593:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1594:stk500boot.c  **** 					break;
1595:stk500boot.c  **** 
1596:stk500boot.c  **** 				case kDUMP_RAM:
1597:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1598:stk500boot.c  **** 					break;
1599:stk500boot.c  **** 
1600:stk500boot.c  **** 			}
1601:stk500boot.c  **** 			PrintHexByte(theValue);
1602:stk500boot.c  **** 			sendchar(0x20);
1603:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1604:stk500boot.c  **** 			{
1605:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1606:stk500boot.c  **** 			}
1607:stk500boot.c  **** 			else
1608:stk500boot.c  **** 			{
1609:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1610:stk500boot.c  **** 			}
1611:stk500boot.c  **** 
1612:stk500boot.c  **** 			myAddressPointer++;
1613:stk500boot.c  **** 		}
1614:stk500boot.c  **** 		asciiDump[16]	=	0;
1615:stk500boot.c  **** 		PrintString(asciiDump);
1616:stk500boot.c  **** 		PrintNewLine();
1617:stk500boot.c  **** 
1618:stk500boot.c  **** 		numRows--;
1619:stk500boot.c  **** 	}
1620:stk500boot.c  **** }
1621:stk500boot.c  **** 
1622:stk500boot.c  **** 
1623:stk500boot.c  **** 
1624:stk500boot.c  **** //************************************************************************
1625:stk500boot.c  **** //*	returns amount of extended memory
1626:stk500boot.c  **** static void	EEPROMtest(void)
1627:stk500boot.c  **** {
1628:stk500boot.c  **** int		ii;
1629:stk500boot.c  **** char	theChar;
1630:stk500boot.c  **** char	theEEPROMchar;
1631:stk500boot.c  **** int		errorCount;
1632:stk500boot.c  **** 
1633:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1634:stk500boot.c  **** 	PrintNewLine();
1635:stk500boot.c  **** 	ii			=	0;
1636:stk500boot.c  **** #if (FLASHEND > 0x10000)
1637:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1638:stk500boot.c  **** #else
1639:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1640:stk500boot.c  **** #endif
1641:stk500boot.c  **** 	{
1642:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1643:stk500boot.c  **** 		if (theChar == 0)
1644:stk500boot.c  **** 		{
1645:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1646:stk500boot.c  **** 		}
1647:stk500boot.c  **** 		else
1648:stk500boot.c  **** 		{
1649:stk500boot.c  **** 			sendchar(theChar);
1650:stk500boot.c  **** 		}
1651:stk500boot.c  **** 		ii++;
1652:stk500boot.c  **** 	}
1653:stk500boot.c  **** 
1654:stk500boot.c  **** 	//*	no go back through and test
1655:stk500boot.c  **** 	PrintNewLine();
1656:stk500boot.c  **** 	PrintNewLine();
1657:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1658:stk500boot.c  **** 	PrintNewLine();
1659:stk500boot.c  **** 	errorCount	=	0;
1660:stk500boot.c  **** 	ii			=	0;
1661:stk500boot.c  **** #if (FLASHEND > 0x10000)
1662:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1663:stk500boot.c  **** #else
1664:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1665:stk500boot.c  **** #endif
1666:stk500boot.c  **** 	{
1667:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1668:stk500boot.c  **** 		if (theEEPROMchar == 0)
1669:stk500boot.c  **** 		{
1670:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1671:stk500boot.c  **** 		}
1672:stk500boot.c  **** 		else
1673:stk500boot.c  **** 		{
1674:stk500boot.c  **** 			sendchar(theEEPROMchar);
1675:stk500boot.c  **** 		}
1676:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1677:stk500boot.c  **** 		{
1678:stk500boot.c  **** 			errorCount++;
1679:stk500boot.c  **** 		}
1680:stk500boot.c  **** 		ii++;
1681:stk500boot.c  **** 	}
1682:stk500boot.c  **** 	PrintNewLine();
1683:stk500boot.c  **** 	PrintNewLine();
1684:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1685:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1686:stk500boot.c  **** 	PrintNewLine();
1687:stk500boot.c  **** 	PrintNewLine();
1688:stk500boot.c  **** 
1689:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1690:stk500boot.c  **** 
1691:stk500boot.c  **** }
1692:stk500boot.c  **** 
1693:stk500boot.c  **** 
1694:stk500boot.c  **** 
1695:stk500boot.c  **** #if (FLASHEND > 0x08000)
1696:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough 
1697:stk500boot.c  **** //*	memory to include this
1698:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1699:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1700:stk500boot.c  **** //		#warning Interrupt vectors not defined
1701:stk500boot.c  **** //	#endif
1702:stk500boot.c  **** #endif
1703:stk500boot.c  **** 
1704:stk500boot.c  **** //************************************************************************
1705:stk500boot.c  **** static void	VectorDisplay(void)
1706:stk500boot.c  **** {
1707:stk500boot.c  **** unsigned long	byte1;
1708:stk500boot.c  **** unsigned long	byte2;
1709:stk500boot.c  **** unsigned long	byte3;
1710:stk500boot.c  **** unsigned long	byte4;
1711:stk500boot.c  **** unsigned long	word1;
1712:stk500boot.c  **** unsigned long	word2;
1713:stk500boot.c  **** int				vectorIndex;
1714:stk500boot.c  **** unsigned long	myMemoryPtr;
1715:stk500boot.c  **** unsigned long	wordMemoryAddress;
1716:stk500boot.c  **** unsigned long	realitiveAddr;
1717:stk500boot.c  **** unsigned long	myFullAddress;
1718:stk500boot.c  **** unsigned long	absoluteAddr;
1719:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1720:stk500boot.c  **** 	long		stringPointer;
1721:stk500boot.c  **** #endif
1722:stk500boot.c  **** 
1723:stk500boot.c  **** 	myMemoryPtr		=	0;
1724:stk500boot.c  **** 	vectorIndex		=	0;
1725:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1726:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1727:stk500boot.c  **** 	//					 V#   ADDR   op code
1728:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1729:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1730:stk500boot.c  **** 	{
1731:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1732:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1733:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1734:stk500boot.c  **** 		sendchar(0x20);
1735:stk500boot.c  **** 		sendchar('-');
1736:stk500boot.c  **** 		sendchar(0x20);
1737:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1738:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1739:stk500boot.c  **** 		sendchar(0x20);
1740:stk500boot.c  **** 		sendchar('=');
1741:stk500boot.c  **** 		sendchar(0x20);
1742:stk500boot.c  **** 
1743:stk500boot.c  **** 	
1744:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1745:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1746:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1747:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1748:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1749:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1750:stk500boot.c  **** 	#else
1751:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1752:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1753:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1754:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1755:stk500boot.c  **** 	#endif
1756:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1757:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1758:stk500boot.c  **** 
1759:stk500boot.c  **** 
1760:stk500boot.c  **** 		PrintHexByte(byte2);
1761:stk500boot.c  **** 		sendchar(0x20);
1762:stk500boot.c  **** 		PrintHexByte(byte1);
1763:stk500boot.c  **** 		sendchar(0x20);
1764:stk500boot.c  **** 		PrintHexByte(byte4);
1765:stk500boot.c  **** 		sendchar(0x20);
1766:stk500boot.c  **** 		PrintHexByte(byte3);
1767:stk500boot.c  **** 		sendchar(0x20);
1768:stk500boot.c  **** 	
1769:stk500boot.c  **** 		if (word1 == 0xffff)
1770:stk500boot.c  **** 		{
1771:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1772:stk500boot.c  **** 		}
1773:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1774:stk500boot.c  **** 		{
1775:stk500boot.c  **** 			//*	rjmp instruction
1776:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1777:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1778:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1779:stk500boot.c  **** 
1780:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1781:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1782:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1783:stk500boot.c  **** 			sendchar(0x20);
1784:stk500boot.c  **** 			sendchar('>');
1785:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1786:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1787:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1788:stk500boot.c  **** 	
1789:stk500boot.c  **** 		}
1790:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1791:stk500boot.c  **** 		{
1792:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1793:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1794:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1795:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1796:stk500boot.c  **** 								word2;
1797:stk500boot.c  **** 							
1798:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1799:stk500boot.c  **** 							
1800:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1801:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1802:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1803:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1804:stk500boot.c  **** 			sendchar(0x20);
1805:stk500boot.c  **** 			sendchar('>');
1806:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1807:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1808:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1809:stk500boot.c  **** 		}
1810:stk500boot.c  **** 
1811:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1812:stk500boot.c  **** 		sendchar(0x20);
1813:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1814:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1815:stk500boot.c  **** 	#else
1816:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1817:stk500boot.c  **** 	#endif
1818:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1819:stk500boot.c  **** 	#endif
1820:stk500boot.c  **** 		PrintNewLine();
1821:stk500boot.c  **** 
1822:stk500boot.c  **** 		vectorIndex++;
1823:stk500boot.c  **** 	}
1824:stk500boot.c  **** }
1825:stk500boot.c  **** 
1826:stk500boot.c  **** //************************************************************************
1827:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1828:stk500boot.c  **** {
 243               		.loc 1 1828 0
 244               		.cfi_startproc
 245               	.LVL14:
 246 000e CF93      		push r28
 247               	.LCFI2:
 248               		.cfi_def_cfa_offset 4
 249               		.cfi_offset 28, -3
 250               	/* prologue: function */
 251               	/* frame size = 0 */
 252               	/* stack size = 1 */
 253               	.L__stack_usage = 1
 254 0010 C82F      		mov r28,r24
1829:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 255               		.loc 1 1829 0
 256 0012 60E0      		ldi r22,0
 257 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 258 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 259               	.LVL15:
 260 0018 0E94 0000 		call PrintFromPROGMEM
 261               	.LVL16:
1830:stk500boot.c  **** 	sendchar(thePortLetter);
 262               		.loc 1 1830 0
 263 001c 8C2F      		mov r24,r28
 264 001e 0E94 0000 		call sendchar
 265               	.LVL17:
 266               	/* epilogue start */
1831:stk500boot.c  **** 	PrintNewLine();
1832:stk500boot.c  **** }
 267               		.loc 1 1832 0
 268 0022 CF91      		pop r28
 269               	.LVL18:
1831:stk500boot.c  **** 	PrintNewLine();
 270               		.loc 1 1831 0
 271 0024 0C94 0000 		jmp PrintNewLine
 272               	.LVL19:
 273               		.cfi_endproc
 274               	.LFE25:
 276               		.text
 277               	.global	PrintFromPROGMEMln
 279               	PrintFromPROGMEMln:
 280               	.LFB16:
1398:stk500boot.c  **** {
 281               		.loc 1 1398 0
 282               		.cfi_startproc
 283               	.LVL20:
 284               	/* prologue: function */
 285               	/* frame size = 0 */
 286               	/* stack size = 0 */
 287               	.L__stack_usage = 0
1399:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 288               		.loc 1 1399 0
 289 006a 0E94 0000 		call PrintFromPROGMEM
 290               	.LVL21:
1401:stk500boot.c  **** 	PrintNewLine();
 291               		.loc 1 1401 0
 292 006e 0C94 0000 		jmp PrintNewLine
 293               	.LVL22:
 294               		.cfi_endproc
 295               	.LFE16:
 297               	.global	PrintString
 299               	PrintString:
 300               	.LFB17:
1407:stk500boot.c  **** {
 301               		.loc 1 1407 0
 302               		.cfi_startproc
 303               	.LVL23:
 304 0072 CF93      		push r28
 305               	.LCFI3:
 306               		.cfi_def_cfa_offset 4
 307               		.cfi_offset 28, -3
 308 0074 DF93      		push r29
 309               	.LCFI4:
 310               		.cfi_def_cfa_offset 5
 311               		.cfi_offset 29, -4
 312               	/* prologue: function */
 313               	/* frame size = 0 */
 314               	/* stack size = 2 */
 315               	.L__stack_usage = 2
 316               	.LVL24:
 317 0076 EC01      		movw r28,r24
 318               	.LVL25:
 319               	.L22:
1415:stk500boot.c  **** 		theChar	=	textString[ii];
 320               		.loc 1 1415 0
 321 0078 8991      		ld r24,Y+
 322               	.LVL26:
1416:stk500boot.c  **** 		if (theChar != 0)
 323               		.loc 1 1416 0
 324 007a 8823      		tst r24
 325 007c 01F0      		breq .L20
1418:stk500boot.c  **** 			sendchar(theChar);
 326               		.loc 1 1418 0
 327 007e 0E94 0000 		call sendchar
 328               	.LVL27:
 329 0082 00C0      		rjmp .L22
 330               	.LVL28:
 331               	.L20:
 332               	/* epilogue start */
1422:stk500boot.c  **** }
 333               		.loc 1 1422 0
 334 0084 DF91      		pop r29
 335 0086 CF91      		pop r28
 336 0088 0895      		ret
 337               		.cfi_endproc
 338               	.LFE17:
 340               	.global	PrintHexByte
 342               	PrintHexByte:
 343               	.LFB18:
1426:stk500boot.c  **** {
 344               		.loc 1 1426 0
 345               		.cfi_startproc
 346               	.LVL29:
 347 008a CF93      		push r28
 348               	.LCFI5:
 349               		.cfi_def_cfa_offset 4
 350               		.cfi_offset 28, -3
 351               	/* prologue: function */
 352               	/* frame size = 0 */
 353               	/* stack size = 1 */
 354               	.L__stack_usage = 1
 355 008c C82F      		mov r28,r24
1429:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
 356               		.loc 1 1429 0
 357 008e 8295      		swap r24
 358               	.LVL30:
 359 0090 8F70      		andi r24,lo8(15)
 360 0092 982F      		mov r25,r24
 361 0094 905D      		subi r25,lo8(-(48))
 362               	.LVL31:
1430:stk500boot.c  **** 	if (theChar > 0x39)
 363               		.loc 1 1430 0
 364 0096 9A33      		cpi r25,lo8(58)
 365 0098 00F0      		brlo .L24
1432:stk500boot.c  **** 		theChar	+=	7;
 366               		.loc 1 1432 0
 367 009a 995F      		subi r25,lo8(-(7))
 368               	.LVL32:
 369               	.L24:
1434:stk500boot.c  **** 	sendchar(theChar );
 370               		.loc 1 1434 0
 371 009c 892F      		mov r24,r25
 372 009e 0E94 0000 		call sendchar
 373               	.LVL33:
1436:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
 374               		.loc 1 1436 0
 375 00a2 CF70      		andi r28,lo8(15)
 376               	.LVL34:
 377 00a4 8C2F      		mov r24,r28
 378 00a6 805D      		subi r24,lo8(-(48))
 379               	.LVL35:
1437:stk500boot.c  **** 	if (theChar > 0x39)
 380               		.loc 1 1437 0
 381 00a8 8A33      		cpi r24,lo8(58)
 382 00aa 00F0      		brlo .L25
1439:stk500boot.c  **** 		theChar	+=	7;
 383               		.loc 1 1439 0
 384 00ac 895F      		subi r24,lo8(-(7))
 385               	.LVL36:
 386               	.L25:
 387               	/* epilogue start */
1442:stk500boot.c  **** }
 388               		.loc 1 1442 0
 389 00ae CF91      		pop r28
1441:stk500boot.c  **** 	sendchar(theChar );
 390               		.loc 1 1441 0
 391 00b0 0C94 0000 		jmp sendchar
 392               	.LVL37:
 393               		.cfi_endproc
 394               	.LFE18:
 396               		.section	.text.unlikely
 398               	DumpHex.constprop.0:
 399               	.LFB30:
1555:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 400               		.loc 1 1555 0
 401               		.cfi_startproc
 402               	.LVL38:
 403 0028 4F92      		push r4
 404               	.LCFI6:
 405               		.cfi_def_cfa_offset 4
 406               		.cfi_offset 4, -3
 407 002a 5F92      		push r5
 408               	.LCFI7:
 409               		.cfi_def_cfa_offset 5
 410               		.cfi_offset 5, -4
 411 002c 6F92      		push r6
 412               	.LCFI8:
 413               		.cfi_def_cfa_offset 6
 414               		.cfi_offset 6, -5
 415 002e 7F92      		push r7
 416               	.LCFI9:
 417               		.cfi_def_cfa_offset 7
 418               		.cfi_offset 7, -6
 419 0030 AF92      		push r10
 420               	.LCFI10:
 421               		.cfi_def_cfa_offset 8
 422               		.cfi_offset 10, -7
 423 0032 BF92      		push r11
 424               	.LCFI11:
 425               		.cfi_def_cfa_offset 9
 426               		.cfi_offset 11, -8
 427 0034 CF92      		push r12
 428               	.LCFI12:
 429               		.cfi_def_cfa_offset 10
 430               		.cfi_offset 12, -9
 431 0036 DF92      		push r13
 432               	.LCFI13:
 433               		.cfi_def_cfa_offset 11
 434               		.cfi_offset 13, -10
 435 0038 EF92      		push r14
 436               	.LCFI14:
 437               		.cfi_def_cfa_offset 12
 438               		.cfi_offset 14, -11
 439 003a FF92      		push r15
 440               	.LCFI15:
 441               		.cfi_def_cfa_offset 13
 442               		.cfi_offset 15, -12
 443 003c 0F93      		push r16
 444               	.LCFI16:
 445               		.cfi_def_cfa_offset 14
 446               		.cfi_offset 16, -13
 447 003e 1F93      		push r17
 448               	.LCFI17:
 449               		.cfi_def_cfa_offset 15
 450               		.cfi_offset 17, -14
 451 0040 CF93      		push r28
 452               	.LCFI18:
 453               		.cfi_def_cfa_offset 16
 454               		.cfi_offset 28, -15
 455 0042 DF93      		push r29
 456               	.LCFI19:
 457               		.cfi_def_cfa_offset 17
 458               		.cfi_offset 29, -16
 459 0044 CDB7      		in r28,__SP_L__
 460 0046 DEB7      		in r29,__SP_H__
 461               	.LCFI20:
 462               		.cfi_def_cfa_register 28
 463 0048 6697      		sbiw r28,22
 464               	.LCFI21:
 465               		.cfi_def_cfa_offset 39
 466 004a 0FB6      		in __tmp_reg__,__SREG__
 467 004c F894      		cli
 468 004e DEBF      		out __SP_H__,r29
 469 0050 0FBE      		out __SREG__,__tmp_reg__
 470 0052 CDBF      		out __SP_L__,r28
 471               	/* prologue: function */
 472               	/* frame size = 22 */
 473               	/* stack size = 36 */
 474               	.L__stack_usage = 36
 475 0054 C82E      		mov r12,r24
 476               	.LVL39:
1555:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 477               		.loc 1 1555 0
 478 0056 80E1      		ldi r24,lo8(16)
 479 0058 D82E      		mov r13,r24
 480               	.LVL40:
1565:stk500boot.c  **** 	theValue			=	0;
 481               		.loc 1 1565 0
 482 005a A12C      		mov r10,__zero_reg__
1555:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 483               		.loc 1 1555 0
 484 005c 7E01      		movw r14,r28
 485 005e 81E1      		ldi r24,17
 486 0060 E80E      		add r14,r24
 487 0062 F11C      		adc r15,__zero_reg__
1609:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 488               		.loc 1 1609 0
 489 0064 9EE2      		ldi r25,lo8(46)
 490 0066 B92E      		mov r11,r25
 491               	.LVL41:
 492               	.L35:
1569:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
 493               		.loc 1 1569 0
 494 0068 4130      		cpi r20,1
 495 006a 5105      		cpc r21,__zero_reg__
 496 006c E1E0      		ldi r30,1
 497 006e 6E07      		cpc r22,r30
 498 0070 7105      		cpc r23,__zero_reg__
 499 0072 00F0      		brlo .L27
1571:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
 500               		.loc 1 1571 0
 501 0074 862F      		mov r24,r22
 502 0076 4B8B      		std Y+19,r20
 503 0078 5C8B      		std Y+20,r21
 504 007a 6D8B      		std Y+21,r22
 505 007c 7E8B      		std Y+22,r23
 506 007e 0E94 0000 		call PrintHexByte
 507               	.LVL42:
 508 0082 7E89      		ldd r23,Y+22
 509 0084 6D89      		ldd r22,Y+21
 510 0086 5C89      		ldd r21,Y+20
 511 0088 4B89      		ldd r20,Y+19
 512               	.L27:
1573:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
 513               		.loc 1 1573 0
 514 008a 852F      		mov r24,r21
 515 008c 4B8B      		std Y+19,r20
 516 008e 5C8B      		std Y+20,r21
 517 0090 6D8B      		std Y+21,r22
 518 0092 7E8B      		std Y+22,r23
 519 0094 0E94 0000 		call PrintHexByte
 520               	.LVL43:
1574:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 521               		.loc 1 1574 0
 522 0098 4B89      		ldd r20,Y+19
 523 009a 842F      		mov r24,r20
 524 009c 0E94 0000 		call PrintHexByte
 525               	.LVL44:
1575:stk500boot.c  **** 		sendchar(0x20);
 526               		.loc 1 1575 0
 527 00a0 80E2      		ldi r24,lo8(32)
 528 00a2 0E94 0000 		call sendchar
 529               	.LVL45:
1576:stk500boot.c  **** 		sendchar('-');
 530               		.loc 1 1576 0
 531 00a6 8DE2      		ldi r24,lo8(45)
 532 00a8 0E94 0000 		call sendchar
 533               	.LVL46:
1577:stk500boot.c  **** 		sendchar(0x20);
 534               		.loc 1 1577 0
 535 00ac 80E2      		ldi r24,lo8(32)
 536 00ae 0E94 0000 		call sendchar
 537               	.LVL47:
1579:stk500boot.c  **** 		asciiDump[0]		=	0;
 538               		.loc 1 1579 0
 539 00b2 1982      		std Y+1,__zero_reg__
 540               	.LVL48:
 541 00b4 8E01      		movw r16,r28
 542 00b6 0F5F      		subi r16,-1
 543 00b8 1F4F      		sbci r17,-1
1555:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
 544               		.loc 1 1555 0
 545 00ba 4B89      		ldd r20,Y+19
 546 00bc 5C89      		ldd r21,Y+20
 547 00be 6D89      		ldd r22,Y+21
 548 00c0 7E89      		ldd r23,Y+22
 549 00c2 2A01      		movw r4,r20
 550 00c4 3B01      		movw r6,r22
 551               	.LVL49:
 552               	.L34:
1582:stk500boot.c  **** 			switch(dumpWhat)
 553               		.loc 1 1582 0
 554 00c6 F1E0      		ldi r31,lo8(1)
 555 00c8 CF16      		cp r12,r31
 556 00ca 01F0      		breq .L30
 557 00cc CF16      		cp r12,r31
 558 00ce 00F0      		brlo .L29
 559 00d0 82E0      		ldi r24,lo8(2)
 560 00d2 C812      		cpse r12,r24
 561 00d4 00C0      		rjmp .L28
 562 00d6 00C0      		rjmp .L31
 563               	.L29:
 564               	.LVL50:
 565               	.LBB47:
1586:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
 566               		.loc 1 1586 0
 567               	/* #APP */
 568               	 ;  1586 "stk500boot.c" 1
 569 00d8 6BBE      		out 59, r6
 570 00da F201      		movw r30, r4
 571 00dc A790      		elpm r10, Z+
 572               		
 573               	 ;  0 "" 2
 574               	.LVL51:
 575               	/* #NOAPP */
 576 00de 00C0      		rjmp .L28
 577               	.LVL52:
 578               	.L30:
 579               	.LBE47:
1593:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
 580               		.loc 1 1593 0
 581 00e0 C201      		movw r24,r4
 582 00e2 4B8B      		std Y+19,r20
 583 00e4 5C8B      		std Y+20,r21
 584 00e6 6D8B      		std Y+21,r22
 585 00e8 7E8B      		std Y+22,r23
 586 00ea 0E94 0000 		call __eerd_byte_m256rfr2
 587               	.LVL53:
 588 00ee A82E      		mov r10,r24
 589               	.LVL54:
 590 00f0 4B89      		ldd r20,Y+19
 591 00f2 5C89      		ldd r21,Y+20
 592 00f4 6D89      		ldd r22,Y+21
 593 00f6 7E89      		ldd r23,Y+22
 594 00f8 00C0      		rjmp .L28
 595               	.L31:
1597:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
 596               		.loc 1 1597 0
 597 00fa F201      		movw r30,r4
 598 00fc A080      		ld r10,Z
 599               	.LVL55:
 600               	.L28:
1601:stk500boot.c  **** 			PrintHexByte(theValue);
 601               		.loc 1 1601 0
 602 00fe 8A2D      		mov r24,r10
 603 0100 4B8B      		std Y+19,r20
 604 0102 5C8B      		std Y+20,r21
 605 0104 6D8B      		std Y+21,r22
 606 0106 7E8B      		std Y+22,r23
 607 0108 0E94 0000 		call PrintHexByte
 608               	.LVL56:
1602:stk500boot.c  **** 			sendchar(0x20);
 609               		.loc 1 1602 0
 610 010c 80E2      		ldi r24,lo8(32)
 611 010e 0E94 0000 		call sendchar
 612               	.LVL57:
1603:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 613               		.loc 1 1603 0
 614 0112 8A2D      		mov r24,r10
 615 0114 8052      		subi r24,lo8(-(-32))
 616 0116 4B89      		ldd r20,Y+19
 617 0118 5C89      		ldd r21,Y+20
 618 011a 6D89      		ldd r22,Y+21
 619 011c 7E89      		ldd r23,Y+22
1605:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
 620               		.loc 1 1605 0
 621 011e F801      		movw r30,r16
1603:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 622               		.loc 1 1603 0
 623 0120 8F35      		cpi r24,lo8(95)
 624 0122 00F4      		brsh .L32
1605:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
 625               		.loc 1 1605 0
 626 0124 A082      		st Z,r10
 627 0126 00C0      		rjmp .L33
 628               	.L32:
1609:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
 629               		.loc 1 1609 0
 630 0128 B082      		st Z,r11
 631               	.L33:
1612:stk500boot.c  **** 			myAddressPointer++;
 632               		.loc 1 1612 0
 633 012a FFEF      		ldi r31,-1
 634 012c 4F1A      		sub r4,r31
 635 012e 5F0A      		sbc r5,r31
 636 0130 6F0A      		sbc r6,r31
 637 0132 7F0A      		sbc r7,r31
 638               	.LVL58:
 639 0134 0F5F      		subi r16,-1
 640 0136 1F4F      		sbci r17,-1
1580:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 641               		.loc 1 1580 0
 642 0138 0E15      		cp r16,r14
 643 013a 1F05      		cpc r17,r15
 644 013c 01F0      		breq .+2
 645 013e 00C0      		rjmp .L34
 646 0140 405F      		subi r20,-16
 647 0142 5F4F      		sbci r21,-1
 648 0144 6F4F      		sbci r22,-1
 649 0146 7F4F      		sbci r23,-1
1614:stk500boot.c  **** 		asciiDump[16]	=	0;
 650               		.loc 1 1614 0
 651 0148 198A      		std Y+17,__zero_reg__
1615:stk500boot.c  **** 		PrintString(asciiDump);
 652               		.loc 1 1615 0
 653 014a CE01      		movw r24,r28
 654 014c 0196      		adiw r24,1
 655 014e 4B8B      		std Y+19,r20
 656 0150 5C8B      		std Y+20,r21
 657 0152 6D8B      		std Y+21,r22
 658 0154 7E8B      		std Y+22,r23
 659 0156 0E94 0000 		call PrintString
 660               	.LVL59:
1616:stk500boot.c  **** 		PrintNewLine();
 661               		.loc 1 1616 0
 662 015a 0E94 0000 		call PrintNewLine
 663               	.LVL60:
 664 015e DA94      		dec r13
1567:stk500boot.c  **** 	while (numRows > 0)
 665               		.loc 1 1567 0
 666 0160 4B89      		ldd r20,Y+19
 667 0162 5C89      		ldd r21,Y+20
 668 0164 6D89      		ldd r22,Y+21
 669 0166 7E89      		ldd r23,Y+22
 670 0168 D110      		cpse r13,__zero_reg__
 671 016a 00C0      		rjmp .L35
 672               	/* epilogue start */
1620:stk500boot.c  **** }
 673               		.loc 1 1620 0
 674 016c 6696      		adiw r28,22
 675               	.LVL61:
 676 016e 0FB6      		in __tmp_reg__,__SREG__
 677 0170 F894      		cli
 678 0172 DEBF      		out __SP_H__,r29
 679 0174 0FBE      		out __SREG__,__tmp_reg__
 680 0176 CDBF      		out __SP_L__,r28
 681 0178 DF91      		pop r29
 682 017a CF91      		pop r28
 683 017c 1F91      		pop r17
 684 017e 0F91      		pop r16
 685 0180 FF90      		pop r15
 686 0182 EF90      		pop r14
 687 0184 DF90      		pop r13
 688 0186 CF90      		pop r12
 689               	.LVL62:
 690 0188 BF90      		pop r11
 691 018a AF90      		pop r10
 692               	.LVL63:
 693 018c 7F90      		pop r7
 694 018e 6F90      		pop r6
 695 0190 5F90      		pop r5
 696 0192 4F90      		pop r4
 697 0194 0895      		ret
 698               		.cfi_endproc
 699               	.LFE30:
 701               		.text
 702               	.global	PrintDecInt
 704               	PrintDecInt:
 705               	.LFB19:
1446:stk500boot.c  **** {
 706               		.loc 1 1446 0
 707               		.cfi_startproc
 708               	.LVL64:
 709 00b4 0F93      		push r16
 710               	.LCFI22:
 711               		.cfi_def_cfa_offset 4
 712               		.cfi_offset 16, -3
 713 00b6 1F93      		push r17
 714               	.LCFI23:
 715               		.cfi_def_cfa_offset 5
 716               		.cfi_offset 17, -4
 717 00b8 CF93      		push r28
 718               	.LCFI24:
 719               		.cfi_def_cfa_offset 6
 720               		.cfi_offset 28, -5
 721 00ba DF93      		push r29
 722               	.LCFI25:
 723               		.cfi_def_cfa_offset 7
 724               		.cfi_offset 29, -6
 725               	/* prologue: function */
 726               	/* frame size = 0 */
 727               	/* stack size = 4 */
 728               	.L__stack_usage = 4
 729 00bc EC01      		movw r28,r24
 730 00be 8B01      		movw r16,r22
 731               	.LVL65:
1452:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 732               		.loc 1 1452 0
 733 00c0 8536      		cpi r24,101
 734 00c2 9105      		cpc r25,__zero_reg__
 735 00c4 04F4      		brge .L39
1452:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
 736               		.loc 1 1452 0 is_stmt 0 discriminator 1
 737 00c6 6330      		cpi r22,3
 738 00c8 7105      		cpc r23,__zero_reg__
 739 00ca 04F0      		brlt .L40
 740               	.L39:
 741               	.LVL66:
1454:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
 742               		.loc 1 1454 0 is_stmt 1
 743 00cc CE01      		movw r24,r28
 744               	.LVL67:
 745 00ce 64E6      		ldi r22,lo8(100)
 746 00d0 70E0      		ldi r23,0
 747               	.LVL68:
 748 00d2 0E94 0000 		call __divmodhi4
 749               	.LVL69:
1455:stk500boot.c  **** 		sendchar(theChar );
 750               		.loc 1 1455 0
 751 00d6 862F      		mov r24,r22
 752 00d8 805D      		subi r24,lo8(-(48))
 753 00da 0E94 0000 		call sendchar
 754               	.LVL70:
 755               	.L40:
1458:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 756               		.loc 1 1458 0
 757 00de CB30      		cpi r28,11
 758 00e0 D105      		cpc r29,__zero_reg__
 759 00e2 04F4      		brge .L41
1458:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
 760               		.loc 1 1458 0 is_stmt 0 discriminator 1
 761 00e4 0230      		cpi r16,2
 762 00e6 1105      		cpc r17,__zero_reg__
 763 00e8 04F0      		brlt .L42
 764               	.L41:
 765               	.LVL71:
1460:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
 766               		.loc 1 1460 0 is_stmt 1
 767 00ea CE01      		movw r24,r28
 768 00ec 64E6      		ldi r22,lo8(100)
 769 00ee 70E0      		ldi r23,0
 770 00f0 0E94 0000 		call __divmodhi4
 771 00f4 6AE0      		ldi r22,lo8(10)
 772 00f6 70E0      		ldi r23,0
 773 00f8 0E94 0000 		call __divmodhi4
1461:stk500boot.c  **** 		sendchar(theChar );
 774               		.loc 1 1461 0
 775 00fc 862F      		mov r24,r22
 776 00fe 805D      		subi r24,lo8(-(48))
 777 0100 0E94 0000 		call sendchar
 778               	.LVL72:
 779               	.L42:
1463:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
 780               		.loc 1 1463 0
 781 0104 CE01      		movw r24,r28
 782 0106 6AE0      		ldi r22,lo8(10)
 783 0108 70E0      		ldi r23,0
 784 010a 0E94 0000 		call __divmodhi4
1464:stk500boot.c  **** 	sendchar(theChar );
 785               		.loc 1 1464 0
 786 010e 805D      		subi r24,lo8(-(48))
 787               	/* epilogue start */
1465:stk500boot.c  **** }
 788               		.loc 1 1465 0
 789 0110 DF91      		pop r29
 790 0112 CF91      		pop r28
 791               	.LVL73:
 792 0114 1F91      		pop r17
 793 0116 0F91      		pop r16
 794               	.LVL74:
1464:stk500boot.c  **** 	sendchar(theChar );
 795               		.loc 1 1464 0
 796 0118 0C94 0000 		jmp sendchar
 797               	.LVL75:
 798               		.cfi_endproc
 799               	.LFE19:
 801               		.section	.text.startup,"ax",@progbits
 802               	.global	main
 804               	main:
 805               	.LFB13:
 561:stk500boot.c  **** {
 806               		.loc 1 561 0
 807               		.cfi_startproc
 808 0000 CF93      		push r28
 809               	.LCFI26:
 810               		.cfi_def_cfa_offset 4
 811               		.cfi_offset 28, -3
 812 0002 DF93      		push r29
 813               	.LCFI27:
 814               		.cfi_def_cfa_offset 5
 815               		.cfi_offset 29, -4
 816 0004 CDB7      		in r28,__SP_L__
 817 0006 DEB7      		in r29,__SP_H__
 818               	.LCFI28:
 819               		.cfi_def_cfa_register 28
 820 0008 CA53      		subi r28,58
 821 000a D140      		sbci r29,1
 822               	.LCFI29:
 823               		.cfi_def_cfa_offset 319
 824 000c 0FB6      		in __tmp_reg__,__SREG__
 825 000e F894      		cli
 826 0010 DEBF      		out __SP_H__,r29
 827 0012 0FBE      		out __SREG__,__tmp_reg__
 828 0014 CDBF      		out __SP_L__,r28
 829               	/* prologue: function */
 830               	/* frame size = 314 */
 831               	/* stack size = 316 */
 832               	.L__stack_usage = 316
 833               	.LVL76:
 582:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 834               		.loc 1 582 0
 835               	/* #APP */
 836               	 ;  582 "stk500boot.c" 1
 837               		.set __stack, -32257
 838               	 ;  0 "" 2
 583:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 839               		.loc 1 583 0
 840               	 ;  583 "stk500boot.c" 1
 841 0016 01E8      		ldi	16, 129
 842               	 ;  0 "" 2
 584:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 843               		.loc 1 584 0
 844               	 ;  584 "stk500boot.c" 1
 845 0018 0EBF      		out 62,16
 846               	 ;  0 "" 2
 585:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 847               		.loc 1 585 0
 848               	 ;  585 "stk500boot.c" 1
 849 001a 0FEF      		ldi	16, 255
 850               	 ;  0 "" 2
 586:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 851               		.loc 1 586 0
 852               	 ;  586 "stk500boot.c" 1
 853 001c 0DBF      		out 61,16
 854               	 ;  0 "" 2
 593:stk500boot.c  **** 	mcuStatusReg	=	MCUSR;
 855               		.loc 1 593 0
 856               	/* #NOAPP */
 857 001e 94B7      		in r25,0x34
 858               	.LVL77:
 595:stk500boot.c  **** 	__asm__ __volatile__ ("cli");
 859               		.loc 1 595 0
 860               	/* #APP */
 861               	 ;  595 "stk500boot.c" 1
 862 0020 F894      		cli
 863               	 ;  0 "" 2
 596:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 864               		.loc 1 596 0
 865               	 ;  596 "stk500boot.c" 1
 866 0022 A895      		wdr
 867               	 ;  0 "" 2
 597:stk500boot.c  **** 	MCUSR	=	0;
 868               		.loc 1 597 0
 869               	/* #NOAPP */
 870 0024 14BE      		out 0x34,__zero_reg__
 598:stk500boot.c  **** 	WDTCSR	|=	_BV(WDCE) | _BV(WDE);
 871               		.loc 1 598 0
 872 0026 8091 6000 		lds r24,96
 873 002a 8861      		ori r24,lo8(24)
 874 002c 8093 6000 		sts 96,r24
 599:stk500boot.c  **** 	WDTCSR	=	0;
 875               		.loc 1 599 0
 876 0030 1092 6000 		sts 96,__zero_reg__
 600:stk500boot.c  **** 	__asm__ __volatile__ ("sei");
 877               		.loc 1 600 0
 878               	/* #APP */
 879               	 ;  600 "stk500boot.c" 1
 880 0034 7894      		sei
 881               	 ;  0 "" 2
 602:stk500boot.c  **** 	if (mcuStatusReg & _BV(WDRF))
 882               		.loc 1 602 0
 883               	/* #NOAPP */
 884 0036 93FF      		sbrs r25,3
 885 0038 00C0      		rjmp .L44
 604:stk500boot.c  **** 		app_start();
 886               		.loc 1 604 0
 887 003a E091 0000 		lds r30,app_start
 888 003e F091 0000 		lds r31,app_start+1
 889 0042 1995      		eicall
 890               	.LVL78:
 891               	.L44:
 626:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 892               		.loc 1 626 0
 893 0044 219A      		sbi 0x4,1
 628:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 894               		.loc 1 628 0
 895 0046 299A      		sbi 0x5,1
 646:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 896               		.loc 1 646 0
 897 0048 8091 C000 		lds r24,192
 898 004c 8260      		ori r24,lo8(2)
 899 004e 8093 C000 		sts 192,r24
 648:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 900               		.loc 1 648 0
 901 0052 87E0      		ldi r24,lo8(7)
 902 0054 8093 C400 		sts 196,r24
 649:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 903               		.loc 1 649 0
 904 0058 88E1      		ldi r24,lo8(24)
 905 005a 8093 C100 		sts 193,r24
 676:stk500boot.c  **** 	UCSRA |= 1 << U2X0;	
 906               		.loc 1 676 0
 907 005e 8091 C000 		lds r24,192
 908 0062 8260      		ori r24,lo8(2)
 909 0064 8093 C000 		sts 192,r24
 682:stk500boot.c  ****   	UCSRB |= (1 << RXEN) | (1 << TXEN);
 910               		.loc 1 682 0
 911 0068 8091 C100 		lds r24,193
 912 006c 8861      		ori r24,lo8(24)
 913 006e 8093 C100 		sts 193,r24
 685:stk500boot.c  ****   	UCSRC |= (0 << USBS1) | (1 << UCSZ10) | (1 << UCSZ11);
 914               		.loc 1 685 0
 915 0072 8091 C200 		lds r24,194
 916 0076 8660      		ori r24,lo8(6)
 917 0078 8093 C200 		sts 194,r24
 688:stk500boot.c  ****   	UBRR0H = (BAUD_PRESCALE >> 8);
 918               		.loc 1 688 0
 919 007c 1092 C500 		sts 197,__zero_reg__
 689:stk500boot.c  ****   	UBRR0L =  BAUD_PRESCALE;
 920               		.loc 1 689 0
 921 0080 80E1      		ldi r24,lo8(16)
 922 0082 8093 C400 		sts 196,r24
 694:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 923               		.loc 1 694 0
 924               	/* #APP */
 925               	 ;  694 "stk500boot.c" 1
 926 0086 0000      		nop
 927               	 ;  0 "" 2
 699:stk500boot.c  **** 	sendchar('s');
 928               		.loc 1 699 0
 929               	/* #NOAPP */
 930 0088 83E7      		ldi r24,lo8(115)
 931 008a 0E94 0000 		call sendchar
 932               	.LVL79:
 700:stk500boot.c  **** 	sendchar('t');
 933               		.loc 1 700 0
 934 008e 84E7      		ldi r24,lo8(116)
 935 0090 0E94 0000 		call sendchar
 936               	.LVL80:
 701:stk500boot.c  **** 	sendchar('k');
 937               		.loc 1 701 0
 938 0094 8BE6      		ldi r24,lo8(107)
 939 0096 0E94 0000 		call sendchar
 940               	.LVL81:
 705:stk500boot.c  **** 	sendchar('v');
 941               		.loc 1 705 0
 942 009a 86E7      		ldi r24,lo8(118)
 943 009c 0E94 0000 		call sendchar
 944               	.LVL82:
 706:stk500boot.c  **** 	sendchar('2');
 945               		.loc 1 706 0
 946 00a0 82E3      		ldi r24,lo8(50)
 947 00a2 0E94 0000 		call sendchar
 948               	.LVL83:
 707:stk500boot.c  **** 	sendchar(0x0d);
 949               		.loc 1 707 0
 950 00a6 8DE0      		ldi r24,lo8(13)
 951 00a8 0E94 0000 		call sendchar
 952               	.LVL84:
 708:stk500boot.c  **** 	sendchar(0x0a);
 953               		.loc 1 708 0
 954 00ac 8AE0      		ldi r24,lo8(10)
 955 00ae 0E94 0000 		call sendchar
 956               	.LVL85:
 710:stk500boot.c  **** 	delay_ms(100);
 957               		.loc 1 710 0
 958 00b2 84E6      		ldi r24,lo8(100)
 959 00b4 90E0      		ldi r25,0
 960 00b6 0E94 0000 		call delay_ms
 961               	.LVL86:
 610:stk500boot.c  **** 	boot_timer	=	0;
 962               		.loc 1 610 0
 963 00ba C12C      		mov r12,__zero_reg__
 964 00bc D12C      		mov r13,__zero_reg__
 965 00be 7601      		movw r14,r12
 724:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 966               		.loc 1 724 0
 967 00c0 27EC      		ldi r18,lo8(-57)
 968 00c2 822E      		mov r8,r18
 969 00c4 2BE1      		ldi r18,lo8(27)
 970 00c6 922E      		mov r9,r18
 971 00c8 A12C      		mov r10,__zero_reg__
 972 00ca B12C      		mov r11,__zero_reg__
 731:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 973               		.loc 1 731 0
 974 00cc 32E0      		ldi r19,lo8(2)
 975 00ce 732E      		mov r7,r19
 976 00d0 00C0      		rjmp .L45
 977               	.LVL87:
 978               	.L49:
 979               	.LBB118:
 980               	.LBB119:
 981               		.loc 2 164 0
 982 00d2 25E0      		ldi r18,lo8(5)
 983 00d4 2A95      		1: dec r18
 984 00d6 01F4      		brne 1b
 985 00d8 0000      		nop
 986               	.LBE119:
 987               	.LBE118:
 718:stk500boot.c  **** 			boot_timer++;
 988               		.loc 1 718 0
 989 00da 3FEF      		ldi r19,-1
 990 00dc C31A      		sub r12,r19
 991 00de D30A      		sbc r13,r19
 992 00e0 E30A      		sbc r14,r19
 993 00e2 F30A      		sbc r15,r19
 994               	.LVL88:
 719:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 995               		.loc 1 719 0
 996 00e4 01E0      		ldi r16,lo8(1)
 997 00e6 10E0      		ldi r17,0
 998               	.LVL89:
 999 00e8 41E9      		ldi r20,-111
 1000 00ea C416      		cp r12,r20
 1001 00ec 4FE5      		ldi r20,95
 1002 00ee D406      		cpc r13,r20
 1003 00f0 41E0      		ldi r20,1
 1004 00f2 E406      		cpc r14,r20
 1005 00f4 F104      		cpc r15,__zero_reg__
 1006 00f6 00F4      		brsh .L46
 1007 00f8 00E0      		ldi r16,0
 1008 00fa 10E0      		ldi r17,0
 1009               	.L46:
 1010               	.LVL90:
 724:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 1011               		.loc 1 724 0
 1012 00fc C701      		movw r24,r14
 1013 00fe B601      		movw r22,r12
 1014 0100 A501      		movw r20,r10
 1015 0102 9401      		movw r18,r8
 1016 0104 0E94 0000 		call __udivmodsi4
 1017 0108 672B      		or r22,r23
 1018 010a 682B      		or r22,r24
 1019 010c 692B      		or r22,r25
 1020 010e 01F4      		brne .L236
 728:stk500boot.c  **** 				sendchar('b');
 1021               		.loc 1 728 0
 1022 0110 82E6      		ldi r24,lo8(98)
 1023 0112 0E94 0000 		call sendchar
 1024               	.LVL91:
 731:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 1025               		.loc 1 731 0
 1026 0116 85B1      		in r24,0x5
 1027 0118 8725      		eor r24,r7
 1028 011a 85B9      		out 0x5,r24
 1029               	.LVL92:
 1030               	.L236:
 1031               	.LBB120:
 1032               	.LBB121:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 1033               		.loc 1 506 0 discriminator 1
 1034 011c 8091 C000 		lds r24,192
 1035               	.LBE121:
 1036               	.LBE120:
 715:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 1037               		.loc 1 715 0 discriminator 1
 1038 0120 87FD      		sbrc r24,7
 1039 0122 00C0      		rjmp .L48
 715:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 1040               		.loc 1 715 0 is_stmt 0 discriminator 2
 1041 0124 0115      		cp r16,__zero_reg__
 1042 0126 1105      		cpc r17,__zero_reg__
 1043 0128 01F0      		breq .L49
 1044               	.L48:
 735:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 1045               		.loc 1 735 0 is_stmt 1
 1046 012a A801      		movw r20,r16
 1047 012c 4F5F      		subi r20,-1
 1048 012e 5F4F      		sbci r21,-1
 1049               	.LVL93:
 713:stk500boot.c  **** 	while (boot_state==0)
 1050               		.loc 1 713 0
 1051 0130 01F4      		brne .L50
 1052               	.LVL94:
 1053               	.L45:
 561:stk500boot.c  **** {
 1054               		.loc 1 561 0 discriminator 1
 1055 0132 00E0      		ldi r16,0
 1056 0134 10E0      		ldi r17,0
 1057 0136 00C0      		rjmp .L236
 1058               	.LVL95:
 1059               	.L50:
 739:stk500boot.c  **** 	if (boot_state==1)
 1060               		.loc 1 739 0
 1061 0138 4130      		cpi r20,1
 1062 013a 5105      		cpc r21,__zero_reg__
 1063 013c 01F0      		breq .+4
 1064 013e 0C94 0000 		jmp .L53
 1065 0142 00C0      		rjmp .L180
 1066               	.LVL96:
 1067               	.L135:
 1068 0144 40E0      		ldi r20,0
 1069 0146 50E0      		ldi r21,0
 1070               	.LVL97:
 1071               	.L177:
 752:stk500boot.c  **** 				if (boot_state==1)
 1072               		.loc 1 752 0
 1073 0148 4130      		cpi r20,1
 1074 014a 5105      		cpc r21,__zero_reg__
 1075 014c 01F4      		brne .L181
 1076               	.LVL98:
 1077 014e 00C0      		rjmp .L242
 1078               	.LVL99:
 1079               	.L57:
 1080               	.LBB122:
 1081               	.LBB123:
 532:stk500boot.c  **** 		count++;
 1082               		.loc 1 532 0
 1083 0150 4F5F      		subi r20,-1
 1084 0152 5F4F      		sbci r21,-1
 1085 0154 6F4F      		sbci r22,-1
 1086 0156 7F4F      		sbci r23,-1
 1087               	.LVL100:
 533:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 1088               		.loc 1 533 0
 1089 0158 4130      		cpi r20,1
 1090 015a 92E1      		ldi r25,18
 1091 015c 5907      		cpc r21,r25
 1092 015e 9AE7      		ldi r25,122
 1093 0160 6907      		cpc r22,r25
 1094 0162 7105      		cpc r23,__zero_reg__
 1095 0164 00F0      		brlo .L237
 1096               	.LVL101:
 1097               	.LBB124:
 541:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 1098               		.loc 1 541 0
 1099 0166 C85C      		subi r28,lo8(-312)
 1100 0168 DE4F      		sbci r29,hi8(-312)
 1101 016a A881      		ld r26,Y
 1102 016c B981      		ldd r27,Y+1
 1103 016e C853      		subi r28,lo8(312)
 1104 0170 D140      		sbci r29,hi8(312)
 1105 0172 1196      		adiw r26,1
 1106 0174 01F0      		breq .L181
 543:stk500boot.c  **** 				asm volatile(
 1107               		.loc 1 543 0
 1108               	/* #APP */
 1109               	 ;  543 "stk500boot.c" 1
 1110 0176 EE27      		clr	r30		
 1111 0178 FF27      		clr	r31		
 1112 017a 0994      		ijmp	
 1113               		
 1114               	 ;  0 "" 2
 1115               	.LVL102:
 1116               	/* #NOAPP */
 1117               	.L181:
 1118               	.LBE124:
 1119               	.LBE123:
 1120               	.LBE122:
 752:stk500boot.c  **** 				if (boot_state==1)
 1121               		.loc 1 752 0
 1122 017c 40E0      		ldi r20,0
 1123 017e 50E0      		ldi r21,0
 1124 0180 BA01      		movw r22,r20
 1125               	.L237:
 1126               	.LVL103:
 1127               	.LBB129:
 1128               	.LBB127:
 529:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 1129               		.loc 1 529 0
 1130 0182 9091 C000 		lds r25,192
 1131 0186 97FF      		sbrs r25,7
 1132 0188 00C0      		rjmp .L57
 1133               	.LVL104:
 1134               	.L242:
 552:stk500boot.c  **** 	return UART_DATA_REG;
 1135               		.loc 1 552 0
 1136 018a 9091 C600 		lds r25,198
 1137               	.LVL105:
 1138               	.LBE127:
 1139               	.LBE129:
 765:stk500boot.c  **** 				rcvdCharCntr++;
 1140               		.loc 1 765 0
 1141 018e C55D      		subi r28,lo8(-299)
 1142 0190 DE4F      		sbci r29,hi8(-299)
 1143 0192 4881      		ld r20,Y
 1144 0194 5981      		ldd r21,Y+1
 1145 0196 CB52      		subi r28,lo8(299)
 1146 0198 D140      		sbci r29,hi8(299)
 1147 019a 4F5F      		subi r20,-1
 1148 019c 5F4F      		sbci r21,-1
 1149 019e C55D      		subi r28,lo8(-299)
 1150 01a0 DE4F      		sbci r29,hi8(-299)
 1151 01a2 5983      		std Y+1,r21
 1152 01a4 4883      		st Y,r20
 1153 01a6 CB52      		subi r28,lo8(299)
 1154 01a8 D140      		sbci r29,hi8(299)
 1155               	.LVL106:
 767:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1156               		.loc 1 767 0
 1157 01aa 9132      		cpi r25,lo8(33)
 1158 01ac 01F0      		breq .+2
 1159 01ae 00C0      		rjmp .L184
 767:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 1160               		.loc 1 767 0 is_stmt 0 discriminator 1
 1161 01b0 4A30      		cpi r20,10
 1162 01b2 5105      		cpc r21,__zero_reg__
 1163 01b4 00F0      		brlo .+2
 1164 01b6 00C0      		rjmp .L184
 769:stk500boot.c  **** 					exPointCntr++;
 1165               		.loc 1 769 0 is_stmt 1
 1166 01b8 5FEF      		ldi r21,-1
 1167 01ba 651A      		sub r6,r21
 1168 01bc 750A      		sbc r7,r21
 1169               	.LVL107:
 770:stk500boot.c  **** 					if (exPointCntr == 3)
 1170               		.loc 1 770 0
 1171 01be 63E0      		ldi r22,3
 1172 01c0 6616      		cp r6,r22
 1173 01c2 7104      		cpc r7,__zero_reg__
 1174 01c4 01F0      		breq .+2
 1175 01c6 00C0      		rjmp .L58
 1176 01c8 00C0      		rjmp .L59
 1177               	.LVL108:
 1178               	.L60:
 1179               	.LBB130:
 1180               	.LBB131:
1833:stk500boot.c  **** 
1834:stk500boot.c  **** //************************************************************************
1835:stk500boot.c  **** static void	ListAvailablePorts(void)
1836:stk500boot.c  **** {
1837:stk500boot.c  **** 
1838:stk500boot.c  **** #ifdef DDRA
1839:stk500boot.c  **** 	PrintAvailablePort('A');
1840:stk500boot.c  **** #endif
1841:stk500boot.c  **** 
1842:stk500boot.c  **** #ifdef DDRB
1843:stk500boot.c  **** 	PrintAvailablePort('B');
1844:stk500boot.c  **** #endif
1845:stk500boot.c  **** 
1846:stk500boot.c  **** #ifdef DDRC
1847:stk500boot.c  **** 	PrintAvailablePort('C');
1848:stk500boot.c  **** #endif
1849:stk500boot.c  **** 
1850:stk500boot.c  **** #ifdef DDRD
1851:stk500boot.c  **** 	PrintAvailablePort('D');
1852:stk500boot.c  **** #endif
1853:stk500boot.c  **** 
1854:stk500boot.c  **** #ifdef DDRE
1855:stk500boot.c  **** 	PrintAvailablePort('E');
1856:stk500boot.c  **** #endif
1857:stk500boot.c  **** 
1858:stk500boot.c  **** #ifdef DDRF
1859:stk500boot.c  **** 	PrintAvailablePort('F');
1860:stk500boot.c  **** #endif
1861:stk500boot.c  **** 
1862:stk500boot.c  **** #ifdef DDRG
1863:stk500boot.c  **** 	PrintAvailablePort('G');
1864:stk500boot.c  **** #endif
1865:stk500boot.c  **** 
1866:stk500boot.c  **** #ifdef DDRH
1867:stk500boot.c  **** 	PrintAvailablePort('H');
1868:stk500boot.c  **** #endif
1869:stk500boot.c  **** 
1870:stk500boot.c  **** #ifdef DDRI
1871:stk500boot.c  **** 	PrintAvailablePort('I');
1872:stk500boot.c  **** #endif
1873:stk500boot.c  **** 
1874:stk500boot.c  **** #ifdef DDRJ
1875:stk500boot.c  **** 	PrintAvailablePort('J');
1876:stk500boot.c  **** #endif
1877:stk500boot.c  **** 
1878:stk500boot.c  **** #ifdef DDRK
1879:stk500boot.c  **** 	PrintAvailablePort('K');
1880:stk500boot.c  **** #endif
1881:stk500boot.c  **** 
1882:stk500boot.c  **** #ifdef DDRL
1883:stk500boot.c  **** 	PrintAvailablePort('L');
1884:stk500boot.c  **** #endif
1885:stk500boot.c  **** 
1886:stk500boot.c  **** }
1887:stk500boot.c  **** 
1888:stk500boot.c  **** //************************************************************************
1889:stk500boot.c  **** static void	AVR_PortOutput(void)
1890:stk500boot.c  **** {
1891:stk500boot.c  **** char	portLetter;
1892:stk500boot.c  **** char	getCharFlag;
1893:stk500boot.c  **** 
1894:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1895:stk500boot.c  **** 
1896:stk500boot.c  **** 	portLetter	=	recchar();
1897:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1898:stk500boot.c  **** 	sendchar(portLetter);
1899:stk500boot.c  **** 	PrintNewLine();
1900:stk500boot.c  **** 
1901:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1902:stk500boot.c  **** 	{
1903:stk500boot.c  **** 		getCharFlag	=	true;
1904:stk500boot.c  **** 		switch(portLetter)
1905:stk500boot.c  **** 		{
1906:stk500boot.c  **** 		#ifdef DDRA
1907:stk500boot.c  **** 			case 'A':
1908:stk500boot.c  **** 				DDRA	=	0xff;
1909:stk500boot.c  **** 				while (!Serial_Available())
1910:stk500boot.c  **** 				{
1911:stk500boot.c  **** 					PORTA	^=	0xff;
1912:stk500boot.c  **** 					delay_ms(200);
1913:stk500boot.c  **** 				}
1914:stk500boot.c  **** 				PORTA	=	0;
1915:stk500boot.c  **** 				break;
1916:stk500boot.c  **** 		#endif
1917:stk500boot.c  **** 
1918:stk500boot.c  **** 		#ifdef DDRB
1919:stk500boot.c  **** 			case 'B':
1920:stk500boot.c  **** 				DDRB	=	0xff;
1921:stk500boot.c  **** 				while (!Serial_Available())
1922:stk500boot.c  **** 				{
1923:stk500boot.c  **** 					PORTB	^=	0xff;
1924:stk500boot.c  **** 					delay_ms(200);
1925:stk500boot.c  **** 				}
1926:stk500boot.c  **** 				PORTB	=	0;
1927:stk500boot.c  **** 				break;
1928:stk500boot.c  **** 		#endif
1929:stk500boot.c  **** 
1930:stk500boot.c  **** 		#ifdef DDRC
1931:stk500boot.c  **** 			case 'C':
1932:stk500boot.c  **** 				DDRC	=	0xff;
1933:stk500boot.c  **** 				while (!Serial_Available())
1934:stk500boot.c  **** 				{
1935:stk500boot.c  **** 					PORTC	^=	0xff;
1936:stk500boot.c  **** 					delay_ms(200);
1937:stk500boot.c  **** 				}
1938:stk500boot.c  **** 				PORTC	=	0;
1939:stk500boot.c  **** 				break;
1940:stk500boot.c  **** 		#endif
1941:stk500boot.c  **** 
1942:stk500boot.c  **** 		#ifdef DDRD
1943:stk500boot.c  **** 			case 'D':
1944:stk500boot.c  **** 				DDRD	=	0xff;
1945:stk500boot.c  **** 				while (!Serial_Available())
1946:stk500boot.c  **** 				{
1947:stk500boot.c  **** 					PORTD	^=	0xff;
1948:stk500boot.c  **** 					delay_ms(200);
1949:stk500boot.c  **** 				}
1950:stk500boot.c  **** 				PORTD	=	0;
1951:stk500boot.c  **** 				break;
1952:stk500boot.c  **** 		#endif
1953:stk500boot.c  **** 
1954:stk500boot.c  **** 		#ifdef DDRE
1955:stk500boot.c  **** 			case 'E':
1956:stk500boot.c  **** 				DDRE	=	0xff;
1957:stk500boot.c  **** 				while (!Serial_Available())
1958:stk500boot.c  **** 				{
1959:stk500boot.c  **** 					PORTE	^=	0xff;
1960:stk500boot.c  **** 					delay_ms(200);
1961:stk500boot.c  **** 				}
1962:stk500boot.c  **** 				PORTE	=	0;
1963:stk500boot.c  **** 				break;
1964:stk500boot.c  **** 		#endif
1965:stk500boot.c  **** 
1966:stk500boot.c  **** 		#ifdef DDRF
1967:stk500boot.c  **** 			case 'F':
1968:stk500boot.c  **** 				DDRF	=	0xff;
1969:stk500boot.c  **** 				while (!Serial_Available())
1970:stk500boot.c  **** 				{
1971:stk500boot.c  **** 					PORTF	^=	0xff;
1972:stk500boot.c  **** 					delay_ms(200);
1973:stk500boot.c  **** 				}
1974:stk500boot.c  **** 				PORTF	=	0;
1975:stk500boot.c  **** 				break;
1976:stk500boot.c  **** 		#endif
1977:stk500boot.c  **** 
1978:stk500boot.c  **** 		#ifdef DDRG
1979:stk500boot.c  **** 			case 'G':
1980:stk500boot.c  **** 				DDRG	=	0xff;
1981:stk500boot.c  **** 				while (!Serial_Available())
1982:stk500boot.c  **** 				{
1983:stk500boot.c  **** 					PORTG	^=	0xff;
1984:stk500boot.c  **** 					delay_ms(200);
1985:stk500boot.c  **** 				}
1986:stk500boot.c  **** 				PORTG	=	0;
1987:stk500boot.c  **** 				break;
1988:stk500boot.c  **** 		#endif
1989:stk500boot.c  **** 
1990:stk500boot.c  **** 		#ifdef DDRH
1991:stk500boot.c  **** 			case 'H':
1992:stk500boot.c  **** 				DDRH	=	0xff;
1993:stk500boot.c  **** 				while (!Serial_Available())
1994:stk500boot.c  **** 				{
1995:stk500boot.c  **** 					PORTH	^=	0xff;
1996:stk500boot.c  **** 					delay_ms(200);
1997:stk500boot.c  **** 				}
1998:stk500boot.c  **** 				PORTH	=	0;
1999:stk500boot.c  **** 				break;
2000:stk500boot.c  **** 		#endif
2001:stk500boot.c  **** 
2002:stk500boot.c  **** 		#ifdef DDRI
2003:stk500boot.c  **** 			case 'I':
2004:stk500boot.c  **** 				DDRI	=	0xff;
2005:stk500boot.c  **** 				while (!Serial_Available())
2006:stk500boot.c  **** 				{
2007:stk500boot.c  **** 					PORTI	^=	0xff;
2008:stk500boot.c  **** 					delay_ms(200);
2009:stk500boot.c  **** 				}
2010:stk500boot.c  **** 				PORTI	=	0;
2011:stk500boot.c  **** 				break;
2012:stk500boot.c  **** 		#endif
2013:stk500boot.c  **** 
2014:stk500boot.c  **** 		#ifdef DDRJ
2015:stk500boot.c  **** 			case 'J':
2016:stk500boot.c  **** 				DDRJ	=	0xff;
2017:stk500boot.c  **** 				while (!Serial_Available())
2018:stk500boot.c  **** 				{
2019:stk500boot.c  **** 					PORTJ	^=	0xff;
2020:stk500boot.c  **** 					delay_ms(200);
2021:stk500boot.c  **** 				}
2022:stk500boot.c  **** 				PORTJ	=	0;
2023:stk500boot.c  **** 				break;
2024:stk500boot.c  **** 		#endif
2025:stk500boot.c  **** 
2026:stk500boot.c  **** 		#ifdef DDRK
2027:stk500boot.c  **** 			case 'K':
2028:stk500boot.c  **** 				DDRK	=	0xff;
2029:stk500boot.c  **** 				while (!Serial_Available())
2030:stk500boot.c  **** 				{
2031:stk500boot.c  **** 					PORTK	^=	0xff;
2032:stk500boot.c  **** 					delay_ms(200);
2033:stk500boot.c  **** 				}
2034:stk500boot.c  **** 				PORTK	=	0;
2035:stk500boot.c  **** 				break;
2036:stk500boot.c  **** 		#endif
2037:stk500boot.c  **** 
2038:stk500boot.c  **** 		#ifdef DDRL
2039:stk500boot.c  **** 			case 'L':
2040:stk500boot.c  **** 				DDRL	=	0xff;
2041:stk500boot.c  **** 				while (!Serial_Available())
2042:stk500boot.c  **** 				{
2043:stk500boot.c  **** 					PORTL	^=	0xff;
2044:stk500boot.c  **** 					delay_ms(200);
2045:stk500boot.c  **** 				}
2046:stk500boot.c  **** 				PORTL	=	0;
2047:stk500boot.c  **** 				break;
2048:stk500boot.c  **** 		#endif
2049:stk500boot.c  **** 
2050:stk500boot.c  **** 			default:
2051:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
2052:stk500boot.c  **** 				getCharFlag	=	false;
2053:stk500boot.c  **** 				break;
2054:stk500boot.c  **** 		}
2055:stk500boot.c  **** 		if (getCharFlag)
2056:stk500boot.c  **** 		{
2057:stk500boot.c  **** 			recchar();
2058:stk500boot.c  **** 		}
2059:stk500boot.c  **** 	}
2060:stk500boot.c  **** 	else
2061:stk500boot.c  **** 	{
2062:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
2063:stk500boot.c  **** 	}
2064:stk500boot.c  **** }
2065:stk500boot.c  **** 
2066:stk500boot.c  **** 
2067:stk500boot.c  **** //*******************************************************************
2068:stk500boot.c  **** static void PrintHelp(void)
2069:stk500boot.c  **** {
2070:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
2071:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
2072:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
2073:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
2074:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
2075:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
2076:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
2077:stk500boot.c  **** 
2078:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
2079:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
2080:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
2081:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
2082:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
2083:stk500boot.c  **** }
2084:stk500boot.c  **** 
2085:stk500boot.c  **** //************************************************************************
2086:stk500boot.c  **** static void	RunMonitor(void)
2087:stk500boot.c  **** {
2088:stk500boot.c  **** char			keepGoing;
2089:stk500boot.c  **** unsigned char	theChar;
2090:stk500boot.c  **** int				ii, jj;
2091:stk500boot.c  **** 
2092:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
2093:stk500boot.c  **** 	{
2094:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2095:stk500boot.c  **** 		{
2096:stk500boot.c  **** 			sendchar('!');
 1181               		.loc 1 2096 0
 1182 01ca 81E2      		ldi r24,lo8(33)
 1183 01cc 0E94 0000 		call sendchar
 1184               	.LVL109:
 1185 01d0 71E0      		ldi r23,1
 1186 01d2 A71A      		sub r10,r23
 1187 01d4 B108      		sbc r11,__zero_reg__
2094:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
 1188               		.loc 1 2094 0
 1189 01d6 01F4      		brne .L60
2097:stk500boot.c  **** 		}
2098:stk500boot.c  **** 		PrintNewLine();
 1190               		.loc 1 2098 0
 1191 01d8 0E94 0000 		call PrintNewLine
 1192               	.LVL110:
 1193 01dc 0150      		subi r16,1
 1194 01de 1109      		sbc r17,__zero_reg__
2092:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
 1195               		.loc 1 2092 0
 1196 01e0 01F4      		brne .L61
 1197 01e2 00C0      		rjmp .L239
 1198               	.LVL111:
 1199               	.L59:
 1200               	.LBE131:
 1201               	.LBE130:
 770:stk500boot.c  **** 					if (exPointCntr == 3)
 1202               		.loc 1 770 0
 1203 01e4 05E0      		ldi r16,lo8(5)
 1204 01e6 10E0      		ldi r17,0
 1205               	.LVL112:
 1206               	.L61:
 752:stk500boot.c  **** 				if (boot_state==1)
 1207               		.loc 1 752 0
 1208 01e8 99E1      		ldi r25,lo8(25)
 1209 01ea A92E      		mov r10,r25
 1210 01ec B12C      		mov r11,__zero_reg__
 1211 01ee 00C0      		rjmp .L60
 1212               	.LVL113:
 1213               	.L239:
 1214               	.LBB182:
 1215               	.LBB181:
2099:stk500boot.c  **** 	}
2100:stk500boot.c  **** 
2101:stk500boot.c  **** 	gRamIndex			=	0;
 1216               		.loc 1 2101 0
 1217 01f0 1092 0000 		sts gRamIndex,__zero_reg__
 1218 01f4 1092 0000 		sts gRamIndex+1,__zero_reg__
 1219 01f8 1092 0000 		sts gRamIndex+2,__zero_reg__
 1220 01fc 1092 0000 		sts gRamIndex+3,__zero_reg__
2102:stk500boot.c  **** 	gFlashIndex			=	0;
 1221               		.loc 1 2102 0
 1222 0200 1092 0000 		sts gFlashIndex,__zero_reg__
 1223 0204 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1224 0208 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1225 020c 1092 0000 		sts gFlashIndex+3,__zero_reg__
2103:stk500boot.c  **** 	gEepromIndex		=	0;
 1226               		.loc 1 2103 0
 1227 0210 1092 0000 		sts gEepromIndex,__zero_reg__
 1228 0214 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1229 0218 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1230 021c 1092 0000 		sts gEepromIndex+3,__zero_reg__
2104:stk500boot.c  **** 
2105:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1231               		.loc 1 2105 0
 1232 0220 60E0      		ldi r22,0
 1233 0222 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1234 0224 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1235 0226 0E94 0000 		call PrintFromPROGMEMln
 1236               	.LVL114:
 1237               	.LBB132:
 1238               	.LBB133:
1944:stk500boot.c  **** 				DDRD	=	0xff;
 1239               		.loc 1 1944 0
 1240 022a 1FEF      		ldi r17,lo8(-1)
 1241               	.L238:
 1242               	.LBE133:
 1243               	.LBE132:
2106:stk500boot.c  **** 
2107:stk500boot.c  **** 	keepGoing	=	1;
2108:stk500boot.c  **** 	while (keepGoing)
2109:stk500boot.c  **** 	{
2110:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1244               		.loc 1 2110 0
 1245 022c 60E0      		ldi r22,0
 1246 022e 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1247 0230 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1248 0232 0E94 0000 		call PrintFromPROGMEM
 1249               	.LVL115:
2111:stk500boot.c  **** 		theChar	=	recchar();
 1250               		.loc 1 2111 0
 1251 0236 0E94 0000 		call recchar
 1252               	.LVL116:
 1253 023a 082F      		mov r16,r24
 1254               	.LVL117:
2112:stk500boot.c  **** 		if (theChar >= 0x60)
 1255               		.loc 1 2112 0
 1256 023c 8036      		cpi r24,lo8(96)
 1257 023e 00F0      		brlo .L63
2113:stk500boot.c  **** 		{
2114:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1258               		.loc 1 2114 0
 1259 0240 0F75      		andi r16,lo8(95)
 1260               	.LVL118:
 1261               	.L63:
2115:stk500boot.c  **** 		}
2116:stk500boot.c  **** 
2117:stk500boot.c  **** 		if (theChar >= 0x20)
 1262               		.loc 1 2117 0
 1263 0242 0032      		cpi r16,lo8(32)
 1264 0244 00F0      		brlo .L64
2118:stk500boot.c  **** 		{
2119:stk500boot.c  **** 			sendchar(theChar);
 1265               		.loc 1 2119 0
 1266 0246 802F      		mov r24,r16
 1267 0248 0E94 0000 		call sendchar
 1268               	.LVL119:
2120:stk500boot.c  **** 			sendchar(0x20);
 1269               		.loc 1 2120 0
 1270 024c 80E2      		ldi r24,lo8(32)
 1271 024e 0E94 0000 		call sendchar
 1272               	.LVL120:
 1273               	.L64:
2121:stk500boot.c  **** 		}
2122:stk500boot.c  **** 
2123:stk500boot.c  **** 		switch(theChar)
 1274               		.loc 1 2123 0
 1275 0252 0834      		cpi r16,lo8(72)
 1276 0254 01F4      		brne .+2
 1277 0256 00C0      		rjmp .L72
 1278 0258 00F4      		brsh .L78
 1279 025a 0234      		cpi r16,lo8(66)
 1280 025c 01F4      		brne .+2
 1281 025e 00C0      		rjmp .L69
 1282 0260 00F4      		brsh .L79
 1283 0262 0033      		cpi r16,lo8(48)
 1284 0264 01F0      		breq .L66
 1285 0266 00F4      		brsh .+2
 1286 0268 00C0      		rjmp .L65
 1287 026a 0F33      		cpi r16,lo8(63)
 1288 026c 01F0      		breq .L67
 1289 026e 0034      		cpi r16,lo8(64)
 1290 0270 01F0      		breq .+2
 1291 0272 00C0      		rjmp .L65
 1292 0274 00C0      		rjmp .L68
 1293               	.L79:
 1294 0276 0534      		cpi r16,lo8(69)
 1295 0278 01F4      		brne .+2
 1296 027a 00C0      		rjmp .L70
 1297 027c 0634      		cpi r16,lo8(70)
 1298 027e 01F0      		breq .+2
 1299 0280 00C0      		rjmp .L65
 1300 0282 00C0      		rjmp .L71
 1301               	.L78:
 1302 0284 0235      		cpi r16,lo8(82)
 1303 0286 01F4      		brne .+2
 1304 0288 00C0      		rjmp .L75
 1305 028a 00F4      		brsh .L80
 1306 028c 0C34      		cpi r16,lo8(76)
 1307 028e 01F4      		brne .+2
 1308 0290 00C0      		rjmp .L73
 1309 0292 0135      		cpi r16,lo8(81)
 1310 0294 01F0      		breq .+2
 1311 0296 00C0      		rjmp .L65
 1312 0298 00C0      		rjmp .L74
 1313               	.L80:
 1314 029a 0635      		cpi r16,lo8(86)
 1315 029c 01F4      		brne .+2
 1316 029e 00C0      		rjmp .L76
 1317 02a0 0935      		cpi r16,lo8(89)
 1318 02a2 01F0      		breq .+2
 1319 02a4 00C0      		rjmp .L65
 1320 02a6 00C0      		rjmp .L77
 1321               	.L66:
2124:stk500boot.c  **** 		{
2125:stk500boot.c  **** 			case '0':
2126:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
 1322               		.loc 1 2126 0
 1323 02a8 62E0      		ldi r22,lo8(2)
 1324 02aa 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1325 02ac 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1326 02ae 0E94 0000 		call PrintFromPROGMEMln
 1327               	.LVL121:
2127:stk500boot.c  **** 				gFlashIndex		=	0;
 1328               		.loc 1 2127 0
 1329 02b2 1092 0000 		sts gFlashIndex,__zero_reg__
 1330 02b6 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1331 02ba 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1332 02be 1092 0000 		sts gFlashIndex+3,__zero_reg__
2128:stk500boot.c  **** 				gRamIndex		=	0;
 1333               		.loc 1 2128 0
 1334 02c2 1092 0000 		sts gRamIndex,__zero_reg__
 1335 02c6 1092 0000 		sts gRamIndex+1,__zero_reg__
 1336 02ca 1092 0000 		sts gRamIndex+2,__zero_reg__
 1337 02ce 1092 0000 		sts gRamIndex+3,__zero_reg__
 1338 02d2 00C0      		rjmp .L244
 1339               	.L67:
2129:stk500boot.c  **** 				gEepromIndex	=	0;
2130:stk500boot.c  **** 				break;
2131:stk500boot.c  **** 
2132:stk500boot.c  **** 			case '?':
2133:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 1340               		.loc 1 2133 0
 1341 02d4 62E0      		ldi r22,lo8(2)
 1342 02d6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1343 02d8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1344 02da 0E94 0000 		call PrintFromPROGMEMln
 1345               	.LVL122:
 1346               	.LBB149:
 1347               	.LBB150:
1475:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1348               		.loc 1 1475 0
 1349 02de 60E0      		ldi r22,0
 1350 02e0 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1351 02e2 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1352 02e4 0E94 0000 		call PrintFromPROGMEMln
 1353               	.LVL123:
1477:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
 1354               		.loc 1 1477 0
 1355 02e8 60E0      		ldi r22,0
 1356 02ea 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1357 02ec 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1358 02ee 0E94 0000 		call PrintFromPROGMEM
 1359               	.LVL124:
1478:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1360               		.loc 1 1478 0
 1361 02f2 60E0      		ldi r22,0
 1362 02f4 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1363 02f6 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1364 02f8 0E94 0000 		call PrintFromPROGMEMln
 1365               	.LVL125:
1480:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
 1366               		.loc 1 1480 0
 1367 02fc 60E0      		ldi r22,0
 1368 02fe 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1369 0300 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1370 0302 0E94 0000 		call PrintFromPROGMEM
 1371               	.LVL126:
1481:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1372               		.loc 1 1481 0
 1373 0306 60E0      		ldi r22,0
 1374 0308 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1375 030a 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1376 030c 0E94 0000 		call PrintFromPROGMEMln
 1377               	.LVL127:
1483:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
 1378               		.loc 1 1483 0
 1379 0310 60E0      		ldi r22,0
 1380 0312 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1381 0314 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1382 0316 0E94 0000 		call PrintFromPROGMEM
 1383               	.LVL128:
 1384               	.LBB151:
 1385               	.LBB152:
1464:stk500boot.c  **** 	sendchar(theChar );
 1386               		.loc 1 1464 0
 1387 031a 86E3      		ldi r24,lo8(54)
 1388 031c 0E94 0000 		call sendchar
 1389               	.LVL129:
 1390               	.LBE152:
 1391               	.LBE151:
1485:stk500boot.c  **** 	PrintNewLine();
 1392               		.loc 1 1485 0
 1393 0320 0E94 0000 		call PrintNewLine
 1394               	.LVL130:
1487:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
 1395               		.loc 1 1487 0
 1396 0324 60E0      		ldi r22,0
 1397 0326 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1398 0328 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1399 032a 0E94 0000 		call PrintFromPROGMEM
 1400               	.LVL131:
1488:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1401               		.loc 1 1488 0
 1402 032e 60E0      		ldi r22,0
 1403 0330 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1404 0332 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1405 0334 0E94 0000 		call PrintFromPROGMEMln
 1406               	.LVL132:
1491:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
 1407               		.loc 1 1491 0
 1408 0338 60E0      		ldi r22,0
 1409 033a 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1410 033c 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1411 033e 0E94 0000 		call PrintFromPROGMEM
 1412               	.LVL133:
1492:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1413               		.loc 1 1492 0
 1414 0342 60E0      		ldi r22,0
 1415 0344 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1416 0346 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1417 0348 0E94 0000 		call PrintFromPROGMEMln
 1418               	.LVL134:
1495:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
 1419               		.loc 1 1495 0
 1420 034c 60E0      		ldi r22,0
 1421 034e 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1422 0350 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1423 0352 0E94 0000 		call PrintFromPROGMEM
 1424               	.LVL135:
1497:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
 1425               		.loc 1 1497 0
 1426 0356 8EE1      		ldi r24,lo8(30)
 1427 0358 0E94 0000 		call PrintHexByte
 1428               	.LVL136:
1498:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1429               		.loc 1 1498 0
 1430 035c 88EA      		ldi r24,lo8(-88)
 1431 035e 0E94 0000 		call PrintHexByte
 1432               	.LVL137:
1499:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1433               		.loc 1 1499 0
 1434 0362 82E0      		ldi r24,lo8(2)
 1435 0364 0E94 0000 		call PrintHexByte
 1436               	.LVL138:
1500:stk500boot.c  **** 	PrintNewLine();
 1437               		.loc 1 1500 0
 1438 0368 0E94 0000 		call PrintNewLine
 1439               	.LVL139:
1506:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
 1440               		.loc 1 1506 0
 1441 036c 60E0      		ldi r22,0
 1442 036e 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1443 0370 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1444 0372 0E94 0000 		call PrintFromPROGMEM
 1445               	.LVL140:
 1446               	.LBB153:
1507:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1447               		.loc 1 1507 0
 1448 0376 29E0      		ldi r18,lo8(9)
 1449 0378 E0E0      		ldi r30,0
 1450 037a F0E0      		ldi r31,0
 1451               	/* #APP */
 1452               	 ;  1507 "stk500boot.c" 1
 1453 037c 2093 5700 		sts 87, r18
 1454 0380 8491      		lpm r24, Z
 1455               		
 1456               	 ;  0 "" 2
 1457               	.LVL141:
 1458               	/* #NOAPP */
 1459               	.LBE153:
1508:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1460               		.loc 1 1508 0
 1461 0382 0E94 0000 		call PrintHexByte
 1462               	.LVL142:
1509:stk500boot.c  **** 	PrintNewLine();
 1463               		.loc 1 1509 0
 1464 0386 0E94 0000 		call PrintNewLine
 1465               	.LVL143:
1511:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
 1466               		.loc 1 1511 0
 1467 038a 60E0      		ldi r22,0
 1468 038c 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1469 038e 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1470 0390 0E94 0000 		call PrintFromPROGMEM
 1471               	.LVL144:
 1472               	.LBB154:
1512:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1473               		.loc 1 1512 0
 1474 0394 29E0      		ldi r18,lo8(9)
 1475 0396 E3E0      		ldi r30,lo8(3)
 1476 0398 F0E0      		ldi r31,0
 1477               	/* #APP */
 1478               	 ;  1512 "stk500boot.c" 1
 1479 039a 2093 5700 		sts 87, r18
 1480 039e 8491      		lpm r24, Z
 1481               		
 1482               	 ;  0 "" 2
 1483               	.LVL145:
 1484               	/* #NOAPP */
 1485               	.LBE154:
1513:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1486               		.loc 1 1513 0
 1487 03a0 0E94 0000 		call PrintHexByte
 1488               	.LVL146:
1514:stk500boot.c  **** 	PrintNewLine();
 1489               		.loc 1 1514 0
 1490 03a4 0E94 0000 		call PrintNewLine
 1491               	.LVL147:
1516:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
 1492               		.loc 1 1516 0
 1493 03a8 60E0      		ldi r22,0
 1494 03aa 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1495 03ac 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1496 03ae 0E94 0000 		call PrintFromPROGMEM
 1497               	.LVL148:
 1498               	.LBB155:
1517:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1499               		.loc 1 1517 0
 1500 03b2 E2E0      		ldi r30,lo8(2)
 1501 03b4 F0E0      		ldi r31,0
 1502 03b6 39E0      		ldi r19,lo8(9)
 1503               	/* #APP */
 1504               	 ;  1517 "stk500boot.c" 1
 1505 03b8 3093 5700 		sts 87, r19
 1506 03bc 8491      		lpm r24, Z
 1507               		
 1508               	 ;  0 "" 2
 1509               	.LVL149:
 1510               	/* #NOAPP */
 1511               	.LBE155:
1518:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1512               		.loc 1 1518 0
 1513 03be 0E94 0000 		call PrintHexByte
 1514               	.LVL150:
1519:stk500boot.c  **** 	PrintNewLine();
 1515               		.loc 1 1519 0
 1516 03c2 0E94 0000 		call PrintNewLine
 1517               	.LVL151:
1521:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
 1518               		.loc 1 1521 0
 1519 03c6 60E0      		ldi r22,0
 1520 03c8 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1521 03ca 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1522 03cc 0E94 0000 		call PrintFromPROGMEM
 1523               	.LVL152:
 1524               	.LBB156:
1522:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1525               		.loc 1 1522 0
 1526 03d0 29E0      		ldi r18,lo8(9)
 1527 03d2 E1E0      		ldi r30,lo8(1)
 1528 03d4 F0E0      		ldi r31,0
 1529               	/* #APP */
 1530               	 ;  1522 "stk500boot.c" 1
 1531 03d6 2093 5700 		sts 87, r18
 1532 03da 8491      		lpm r24, Z
 1533               		
 1534               	 ;  0 "" 2
 1535               	.LVL153:
 1536               	/* #NOAPP */
 1537               	.LBE156:
1523:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1538               		.loc 1 1523 0
 1539 03dc 0E94 0000 		call PrintHexByte
 1540               	.LVL154:
1524:stk500boot.c  **** 	PrintNewLine();
 1541               		.loc 1 1524 0
 1542 03e0 0E94 0000 		call PrintNewLine
 1543               	.LVL155:
 1544 03e4 00C0      		rjmp .L238
 1545               	.LVL156:
 1546               	.L68:
 1547               	.LBE150:
 1548               	.LBE149:
2134:stk500boot.c  **** 				PrintCPUstats();
2135:stk500boot.c  **** 				break;
2136:stk500boot.c  **** 
2137:stk500boot.c  **** 			case '@':
2138:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
 1549               		.loc 1 2138 0
 1550 03e6 62E0      		ldi r22,lo8(2)
 1551 03e8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1552 03ea 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1553 03ec 0E94 0000 		call PrintFromPROGMEMln
 1554               	.LVL157:
 1555               	.LBB157:
 1556               	.LBB158:
1633:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
 1557               		.loc 1 1633 0
 1558 03f0 60E0      		ldi r22,0
 1559 03f2 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1560 03f4 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1561 03f6 0E94 0000 		call PrintFromPROGMEMln
 1562               	.LVL158:
1634:stk500boot.c  **** 	PrintNewLine();
 1563               		.loc 1 1634 0
 1564 03fa 0E94 0000 		call PrintNewLine
 1565               	.LVL159:
1635:stk500boot.c  **** 	ii			=	0;
 1566               		.loc 1 1635 0
 1567 03fe A12C      		mov r10,__zero_reg__
 1568 0400 B12C      		mov r11,__zero_reg__
 1569 0402 00C0      		rjmp .L82
 1570               	.LVL160:
 1571               	.L86:
1642:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
 1572               		.loc 1 1642 0
 1573 0404 602F      		mov r22,r16
 1574 0406 C501      		movw r24,r10
 1575 0408 0E94 0000 		call __eewr_byte_m256rfr2
 1576               	.LVL161:
1643:stk500boot.c  **** 		if (theChar == 0)
 1577               		.loc 1 1643 0
 1578 040c 0111      		cpse r16,__zero_reg__
 1579 040e 00C0      		rjmp .L83
1645:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 1580               		.loc 1 1645 0
 1581 0410 60E0      		ldi r22,0
 1582 0412 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1583 0414 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1584 0416 0E94 0000 		call PrintFromPROGMEM
 1585               	.LVL162:
 1586 041a 00C0      		rjmp .L84
 1587               	.L83:
1649:stk500boot.c  **** 			sendchar(theChar);
 1588               		.loc 1 1649 0
 1589 041c 802F      		mov r24,r16
 1590 041e 0E94 0000 		call sendchar
 1591               	.LVL163:
 1592               	.L84:
1651:stk500boot.c  **** 		ii++;
 1593               		.loc 1 1651 0
 1594 0422 3FEF      		ldi r19,-1
 1595 0424 A31A      		sub r10,r19
 1596 0426 B30A      		sbc r11,r19
 1597               	.LVL164:
 1598               	.L82:
 1599               	.LBB159:
 560:stk500boot.c  **** int main(void)
 1600               		.loc 1 560 0
 1601 0428 C501      		movw r24,r10
 1602 042a 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1603 042c 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
1637:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
 1604               		.loc 1 1637 0
 1605 042e A0E0      		ldi r26,0
 1606 0430 B0E0      		ldi r27,0
 1607               	/* #APP */
 1608               	 ;  1637 "stk500boot.c" 1
 1609 0432 ABBF      		out 59, r26
 1610 0434 FC01      		movw r30, r24
 1611 0436 0791      		elpm r16, Z+
 1612               		
 1613               	 ;  0 "" 2
 1614               	.LVL165:
 1615               	/* #NOAPP */
 1616               	.LBE159:
 1617 0438 0A32      		cpi r16,lo8(42)
 1618 043a 01F0      		breq .L85
 1619 043c A114      		cp r10,__zero_reg__
 1620 043e 42E0      		ldi r20,2
 1621 0440 B406      		cpc r11,r20
 1622 0442 01F4      		brne .L86
 1623               	.L85:
1655:stk500boot.c  **** 	PrintNewLine();
 1624               		.loc 1 1655 0
 1625 0444 0E94 0000 		call PrintNewLine
 1626               	.LVL166:
1656:stk500boot.c  **** 	PrintNewLine();
 1627               		.loc 1 1656 0
 1628 0448 0E94 0000 		call PrintNewLine
 1629               	.LVL167:
1657:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1630               		.loc 1 1657 0
 1631 044c 60E0      		ldi r22,0
 1632 044e 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1633 0450 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1634 0452 0E94 0000 		call PrintFromPROGMEMln
 1635               	.LVL168:
1658:stk500boot.c  **** 	PrintNewLine();
 1636               		.loc 1 1658 0
 1637 0456 0E94 0000 		call PrintNewLine
 1638               	.LVL169:
1659:stk500boot.c  **** 	errorCount	=	0;
 1639               		.loc 1 1659 0
 1640 045a 812C      		mov r8,__zero_reg__
 1641 045c 912C      		mov r9,__zero_reg__
1660:stk500boot.c  **** 	ii			=	0;
 1642               		.loc 1 1660 0
 1643 045e A12C      		mov r10,__zero_reg__
 1644 0460 B12C      		mov r11,__zero_reg__
 1645               	.LVL170:
 1646 0462 00C0      		rjmp .L87
 1647               	.LVL171:
 1648               	.L92:
1667:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
 1649               		.loc 1 1667 0
 1650 0464 C501      		movw r24,r10
 1651 0466 0E94 0000 		call __eerd_byte_m256rfr2
 1652               	.LVL172:
 1653 046a 782E      		mov r7,r24
 1654               	.LVL173:
1668:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1655               		.loc 1 1668 0
 1656 046c 8111      		cpse r24,__zero_reg__
 1657 046e 00C0      		rjmp .L88
1670:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
 1658               		.loc 1 1670 0
 1659 0470 60E0      		ldi r22,0
 1660 0472 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1661 0474 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1662 0476 0E94 0000 		call PrintFromPROGMEM
 1663               	.LVL174:
 1664 047a 00C0      		rjmp .L89
 1665               	.L88:
1674:stk500boot.c  **** 			sendchar(theEEPROMchar);
 1666               		.loc 1 1674 0
 1667 047c 0E94 0000 		call sendchar
 1668               	.LVL175:
 1669               	.L89:
1676:stk500boot.c  **** 		if (theEEPROMchar != theChar)
 1670               		.loc 1 1676 0
 1671 0480 7016      		cp r7,r16
 1672 0482 01F0      		breq .L90
1678:stk500boot.c  **** 			errorCount++;
 1673               		.loc 1 1678 0
 1674 0484 5FEF      		ldi r21,-1
 1675 0486 851A      		sub r8,r21
 1676 0488 950A      		sbc r9,r21
 1677               	.LVL176:
 1678               	.L90:
1680:stk500boot.c  **** 		ii++;
 1679               		.loc 1 1680 0
 1680 048a 6FEF      		ldi r22,-1
 1681 048c A61A      		sub r10,r22
 1682 048e B60A      		sbc r11,r22
 1683               	.LVL177:
 1684               	.L87:
 1685               	.LBB160:
 560:stk500boot.c  **** int main(void)
 1686               		.loc 1 560 0
 1687 0490 C501      		movw r24,r10
 1688 0492 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1689 0494 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
1662:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
 1690               		.loc 1 1662 0
 1691 0496 A0E0      		ldi r26,0
 1692 0498 B0E0      		ldi r27,0
 1693               	/* #APP */
 1694               	 ;  1662 "stk500boot.c" 1
 1695 049a ABBF      		out 59, r26
 1696 049c FC01      		movw r30, r24
 1697 049e 0791      		elpm r16, Z+
 1698               		
 1699               	 ;  0 "" 2
 1700               	.LVL178:
 1701               	/* #NOAPP */
 1702               	.LBE160:
 1703 04a0 0A32      		cpi r16,lo8(42)
 1704 04a2 01F0      		breq .L91
 1705 04a4 A114      		cp r10,__zero_reg__
 1706 04a6 72E0      		ldi r23,2
 1707 04a8 B706      		cpc r11,r23
 1708 04aa 01F4      		brne .L92
 1709               	.L91:
1682:stk500boot.c  **** 	PrintNewLine();
 1710               		.loc 1 1682 0
 1711 04ac 0E94 0000 		call PrintNewLine
 1712               	.LVL179:
1683:stk500boot.c  **** 	PrintNewLine();
 1713               		.loc 1 1683 0
 1714 04b0 0E94 0000 		call PrintNewLine
 1715               	.LVL180:
1684:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1716               		.loc 1 1684 0
 1717 04b4 60E0      		ldi r22,0
 1718 04b6 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1719 04b8 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1720 04ba 0E94 0000 		call PrintFromPROGMEM
 1721               	.LVL181:
1685:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1722               		.loc 1 1685 0
 1723 04be 61E0      		ldi r22,lo8(1)
 1724 04c0 70E0      		ldi r23,0
 1725 04c2 C401      		movw r24,r8
 1726 04c4 0E94 0000 		call PrintDecInt
 1727               	.LVL182:
1686:stk500boot.c  **** 	PrintNewLine();
 1728               		.loc 1 1686 0
 1729 04c8 0E94 0000 		call PrintNewLine
 1730               	.LVL183:
1687:stk500boot.c  **** 	PrintNewLine();
 1731               		.loc 1 1687 0
 1732 04cc 0E94 0000 		call PrintNewLine
 1733               	.LVL184:
 1734               	.L244:
1689:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
 1735               		.loc 1 1689 0
 1736 04d0 1092 0000 		sts gEepromIndex,__zero_reg__
 1737 04d4 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1738 04d8 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1739 04dc 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1740 04e0 00C0      		rjmp .L238
 1741               	.LVL185:
 1742               	.L69:
 1743               	.LBE158:
 1744               	.LBE157:
2139:stk500boot.c  **** 				EEPROMtest();
2140:stk500boot.c  **** 				break;
2141:stk500boot.c  **** 
2142:stk500boot.c  **** 			case 'B':
2143:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
 1745               		.loc 1 2143 0
 1746 04e2 62E0      		ldi r22,lo8(2)
 1747 04e4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1748 04e6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1749 04e8 0E94 0000 		call PrintFromPROGMEMln
 1750               	.LVL186:
 1751               	.LBB161:
 1752               	.LBB162:
1534:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 1753               		.loc 1 1534 0
 1754 04ec 219A      		sbi 0x4,1
1535:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1755               		.loc 1 1535 0
 1756 04ee 299A      		sbi 0x5,1
 1757 04f0 00C0      		rjmp .L93
 1758               	.L94:
1539:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 1759               		.loc 1 1539 0
 1760 04f2 2998      		cbi 0x5,1
1540:stk500boot.c  **** 		delay_ms(100);
 1761               		.loc 1 1540 0
 1762 04f4 84E6      		ldi r24,lo8(100)
 1763 04f6 90E0      		ldi r25,0
 1764 04f8 0E94 0000 		call delay_ms
 1765               	.LVL187:
1541:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1766               		.loc 1 1541 0
 1767 04fc 299A      		sbi 0x5,1
1542:stk500boot.c  **** 		delay_ms(100);
 1768               		.loc 1 1542 0
 1769 04fe 84E6      		ldi r24,lo8(100)
 1770 0500 90E0      		ldi r25,0
 1771 0502 0E94 0000 		call delay_ms
 1772               	.LVL188:
 1773               	.L93:
 1774               	.LBB163:
 1775               	.LBB164:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 1776               		.loc 1 506 0
 1777 0506 8091 C000 		lds r24,192
 1778               	.LBE164:
 1779               	.LBE163:
1537:stk500boot.c  **** 	while (!Serial_Available())
 1780               		.loc 1 1537 0
 1781 050a 87FF      		sbrs r24,7
 1782 050c 00C0      		rjmp .L94
 1783               	.LVL189:
 1784               	.L112:
1544:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
 1785               		.loc 1 1544 0
 1786 050e 0E94 0000 		call recchar
 1787               	.LVL190:
 1788 0512 00C0      		rjmp .L238
 1789               	.LVL191:
 1790               	.L70:
 1791               	.LBE162:
 1792               	.LBE161:
2144:stk500boot.c  **** 				BlinkLED();
2145:stk500boot.c  **** 				break;
2146:stk500boot.c  **** 
2147:stk500boot.c  **** 			case 'E':
2148:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
 1793               		.loc 1 2148 0
 1794 0514 62E0      		ldi r22,lo8(2)
 1795 0516 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1796 0518 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1797 051a 0E94 0000 		call PrintFromPROGMEMln
 1798               	.LVL192:
2149:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1799               		.loc 1 2149 0
 1800 051e 4091 0000 		lds r20,gEepromIndex
 1801 0522 5091 0000 		lds r21,gEepromIndex+1
 1802 0526 6091 0000 		lds r22,gEepromIndex+2
 1803 052a 7091 0000 		lds r23,gEepromIndex+3
 1804 052e 81E0      		ldi r24,lo8(1)
 1805 0530 0E94 0000 		call DumpHex.constprop.0
 1806               	.LVL193:
2150:stk500boot.c  **** 				gEepromIndex	+=	256;
 1807               		.loc 1 2150 0
 1808 0534 8091 0000 		lds r24,gEepromIndex
 1809 0538 9091 0000 		lds r25,gEepromIndex+1
 1810 053c A091 0000 		lds r26,gEepromIndex+2
 1811 0540 B091 0000 		lds r27,gEepromIndex+3
 1812 0544 9F5F      		subi r25,-1
 1813 0546 AF4F      		sbci r26,-1
 1814 0548 BF4F      		sbci r27,-1
 1815 054a 8093 0000 		sts gEepromIndex,r24
 1816 054e 9093 0000 		sts gEepromIndex+1,r25
 1817 0552 A093 0000 		sts gEepromIndex+2,r26
 1818 0556 B093 0000 		sts gEepromIndex+3,r27
2151:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1819               		.loc 1 2151 0
 1820 055a 8115      		cp r24,__zero_reg__
 1821 055c 9042      		sbci r25,32
 1822 055e A105      		cpc r26,__zero_reg__
 1823 0560 B105      		cpc r27,__zero_reg__
 1824 0562 00F4      		brsh .+2
 1825 0564 00C0      		rjmp .L238
 1826 0566 00C0      		rjmp .L244
 1827               	.L71:
2152:stk500boot.c  **** 				{
2153:stk500boot.c  **** 					gEepromIndex	=	0;
2154:stk500boot.c  **** 				}
2155:stk500boot.c  **** 				break;
2156:stk500boot.c  **** 		
2157:stk500boot.c  **** 			case 'F':
2158:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
 1828               		.loc 1 2158 0
 1829 0568 62E0      		ldi r22,lo8(2)
 1830 056a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1831 056c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1832 056e 0E94 0000 		call PrintFromPROGMEMln
 1833               	.LVL194:
2159:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1834               		.loc 1 2159 0
 1835 0572 4091 0000 		lds r20,gFlashIndex
 1836 0576 5091 0000 		lds r21,gFlashIndex+1
 1837 057a 6091 0000 		lds r22,gFlashIndex+2
 1838 057e 7091 0000 		lds r23,gFlashIndex+3
 1839 0582 80E0      		ldi r24,0
 1840 0584 0E94 0000 		call DumpHex.constprop.0
 1841               	.LVL195:
2160:stk500boot.c  **** 				gFlashIndex	+=	256;
 1842               		.loc 1 2160 0
 1843 0588 8091 0000 		lds r24,gFlashIndex
 1844 058c 9091 0000 		lds r25,gFlashIndex+1
 1845 0590 A091 0000 		lds r26,gFlashIndex+2
 1846 0594 B091 0000 		lds r27,gFlashIndex+3
 1847 0598 9F5F      		subi r25,-1
 1848 059a AF4F      		sbci r26,-1
 1849 059c BF4F      		sbci r27,-1
 1850 059e 8093 0000 		sts gFlashIndex,r24
 1851 05a2 9093 0000 		sts gFlashIndex+1,r25
 1852 05a6 A093 0000 		sts gFlashIndex+2,r26
 1853 05aa B093 0000 		sts gFlashIndex+3,r27
 1854 05ae 00C0      		rjmp .L238
 1855               	.L72:
2161:stk500boot.c  **** 				break;
2162:stk500boot.c  **** 
2163:stk500boot.c  **** 			case 'H':
2164:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
 1856               		.loc 1 2164 0
 1857 05b0 62E0      		ldi r22,lo8(2)
 1858 05b2 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1859 05b4 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1860 05b6 0E94 0000 		call PrintFromPROGMEMln
 1861               	.LVL196:
 1862               	.LBB165:
 1863               	.LBB166:
2070:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
 1864               		.loc 1 2070 0
 1865 05ba 60E0      		ldi r22,0
 1866 05bc 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1867 05be 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1868 05c0 0E94 0000 		call PrintFromPROGMEMln
 1869               	.LVL197:
2071:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1870               		.loc 1 2071 0
 1871 05c4 60E0      		ldi r22,0
 1872 05c6 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1873 05c8 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1874 05ca 0E94 0000 		call PrintFromPROGMEMln
 1875               	.LVL198:
2072:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1876               		.loc 1 2072 0
 1877 05ce 60E0      		ldi r22,0
 1878 05d0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1879 05d2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1880 05d4 0E94 0000 		call PrintFromPROGMEMln
 1881               	.LVL199:
2073:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1882               		.loc 1 2073 0
 1883 05d8 60E0      		ldi r22,0
 1884 05da 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1885 05dc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1886 05de 0E94 0000 		call PrintFromPROGMEMln
 1887               	.LVL200:
2074:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1888               		.loc 1 2074 0
 1889 05e2 60E0      		ldi r22,0
 1890 05e4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1891 05e6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1892 05e8 0E94 0000 		call PrintFromPROGMEMln
 1893               	.LVL201:
2075:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1894               		.loc 1 2075 0
 1895 05ec 60E0      		ldi r22,0
 1896 05ee 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1897 05f0 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1898 05f2 0E94 0000 		call PrintFromPROGMEMln
 1899               	.LVL202:
2076:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1900               		.loc 1 2076 0
 1901 05f6 60E0      		ldi r22,0
 1902 05f8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1903 05fa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1904 05fc 0E94 0000 		call PrintFromPROGMEMln
 1905               	.LVL203:
2078:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
 1906               		.loc 1 2078 0
 1907 0600 60E0      		ldi r22,0
 1908 0602 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1909 0604 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1910 0606 0E94 0000 		call PrintFromPROGMEMln
 1911               	.LVL204:
2079:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1912               		.loc 1 2079 0
 1913 060a 60E0      		ldi r22,0
 1914 060c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1915 060e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1916 0610 0E94 0000 		call PrintFromPROGMEMln
 1917               	.LVL205:
2080:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1918               		.loc 1 2080 0
 1919 0614 60E0      		ldi r22,0
 1920 0616 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1921 0618 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1922 061a 0E94 0000 		call PrintFromPROGMEMln
 1923               	.LVL206:
2081:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1924               		.loc 1 2081 0
 1925 061e 60E0      		ldi r22,0
 1926 0620 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1927 0622 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1928 0624 0E94 0000 		call PrintFromPROGMEMln
 1929               	.LVL207:
2082:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1930               		.loc 1 2082 0
 1931 0628 60E0      		ldi r22,0
 1932 062a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1933 062c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1934 062e 00C0      		rjmp .L243
 1935               	.L73:
 1936               	.LBE166:
 1937               	.LBE165:
2165:stk500boot.c  **** 				PrintHelp();
2166:stk500boot.c  **** 				break;
2167:stk500boot.c  **** 
2168:stk500boot.c  **** 			case 'L':
2169:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1938               		.loc 1 2169 0
 1939 0630 62E0      		ldi r22,lo8(2)
 1940 0632 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1941 0634 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1942 0636 0E94 0000 		call PrintFromPROGMEMln
 1943               	.LVL208:
 1944               	.LBB167:
 1945               	.LBB168:
1839:stk500boot.c  **** 	PrintAvailablePort('A');
 1946               		.loc 1 1839 0
 1947 063a 81E4      		ldi r24,lo8(65)
 1948 063c 0E94 0000 		call PrintAvailablePort
 1949               	.LVL209:
1843:stk500boot.c  **** 	PrintAvailablePort('B');
 1950               		.loc 1 1843 0
 1951 0640 82E4      		ldi r24,lo8(66)
 1952 0642 0E94 0000 		call PrintAvailablePort
 1953               	.LVL210:
1847:stk500boot.c  **** 	PrintAvailablePort('C');
 1954               		.loc 1 1847 0
 1955 0646 83E4      		ldi r24,lo8(67)
 1956 0648 0E94 0000 		call PrintAvailablePort
 1957               	.LVL211:
1851:stk500boot.c  **** 	PrintAvailablePort('D');
 1958               		.loc 1 1851 0
 1959 064c 84E4      		ldi r24,lo8(68)
 1960 064e 0E94 0000 		call PrintAvailablePort
 1961               	.LVL212:
1855:stk500boot.c  **** 	PrintAvailablePort('E');
 1962               		.loc 1 1855 0
 1963 0652 85E4      		ldi r24,lo8(69)
 1964 0654 0E94 0000 		call PrintAvailablePort
 1965               	.LVL213:
1859:stk500boot.c  **** 	PrintAvailablePort('F');
 1966               		.loc 1 1859 0
 1967 0658 86E4      		ldi r24,lo8(70)
 1968 065a 0E94 0000 		call PrintAvailablePort
 1969               	.LVL214:
1863:stk500boot.c  **** 	PrintAvailablePort('G');
 1970               		.loc 1 1863 0
 1971 065e 87E4      		ldi r24,lo8(71)
 1972 0660 0E94 0000 		call PrintAvailablePort
 1973               	.LVL215:
 1974 0664 00C0      		rjmp .L238
 1975               	.L74:
 1976               	.LBE168:
 1977               	.LBE167:
2170:stk500boot.c  **** 				ListAvailablePorts();
2171:stk500boot.c  **** 				break;
2172:stk500boot.c  **** 
2173:stk500boot.c  **** 			case 'Q':
2174:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
 1978               		.loc 1 2174 0
 1979 0666 62E0      		ldi r22,lo8(2)
 1980 0668 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1981 066a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1982 066c 0E94 0000 		call PrintFromPROGMEMln
 1983               	.LVL216:
 773:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 1984               		.loc 1 773 0
 1985 0670 612C      		mov r6,__zero_reg__
 1986 0672 712C      		mov r7,__zero_reg__
 1987               	.LVL217:
 774:stk500boot.c  **** 						isLeave			=	1;
 1988               		.loc 1 774 0
 1989 0674 5524      		clr r5
 1990 0676 5394      		inc r5
 1991 0678 00C0      		rjmp .L95
 1992               	.LVL218:
 1993               	.L75:
2175:stk500boot.c  **** 				keepGoing	=	false;
2176:stk500boot.c  **** 				break;
2177:stk500boot.c  **** 
2178:stk500boot.c  **** 			case 'R':
2179:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1994               		.loc 1 2179 0
 1995 067a 62E0      		ldi r22,lo8(2)
 1996 067c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1997 067e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1998 0680 0E94 0000 		call PrintFromPROGMEMln
 1999               	.LVL219:
2180:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 2000               		.loc 1 2180 0
 2001 0684 4091 0000 		lds r20,gRamIndex
 2002 0688 5091 0000 		lds r21,gRamIndex+1
 2003 068c 6091 0000 		lds r22,gRamIndex+2
 2004 0690 7091 0000 		lds r23,gRamIndex+3
 2005 0694 82E0      		ldi r24,lo8(2)
 2006 0696 0E94 0000 		call DumpHex.constprop.0
 2007               	.LVL220:
2181:stk500boot.c  **** 				gRamIndex	+=	256;
 2008               		.loc 1 2181 0
 2009 069a 8091 0000 		lds r24,gRamIndex
 2010 069e 9091 0000 		lds r25,gRamIndex+1
 2011 06a2 A091 0000 		lds r26,gRamIndex+2
 2012 06a6 B091 0000 		lds r27,gRamIndex+3
 2013 06aa 9F5F      		subi r25,-1
 2014 06ac AF4F      		sbci r26,-1
 2015 06ae BF4F      		sbci r27,-1
 2016 06b0 8093 0000 		sts gRamIndex,r24
 2017 06b4 9093 0000 		sts gRamIndex+1,r25
 2018 06b8 A093 0000 		sts gRamIndex+2,r26
 2019 06bc B093 0000 		sts gRamIndex+3,r27
 2020 06c0 00C0      		rjmp .L238
 2021               	.L76:
2182:stk500boot.c  **** 				break;
2183:stk500boot.c  **** 
2184:stk500boot.c  **** 			case 'V':
2185:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 2022               		.loc 1 2185 0
 2023 06c2 62E0      		ldi r22,lo8(2)
 2024 06c4 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 2025 06c6 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 2026 06c8 0E94 0000 		call PrintFromPROGMEMln
 2027               	.LVL221:
 2028               	.LBB169:
 2029               	.LBB170:
1725:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 2030               		.loc 1 1725 0
 2031 06cc 60E0      		ldi r22,0
 2032 06ce 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 2033 06d0 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 2034 06d2 0E94 0000 		call PrintFromPROGMEMln
 2035               	.LVL222:
1726:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 2036               		.loc 1 1726 0
 2037 06d6 60E0      		ldi r22,0
 2038 06d8 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 2039 06da 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 2040 06dc 0E94 0000 		call PrintFromPROGMEMln
 2041               	.LVL223:
1724:stk500boot.c  **** 	vectorIndex		=	0;
 2042               		.loc 1 1724 0
 2043 06e0 CA5D      		subi r28,lo8(-294)
 2044 06e2 DE4F      		sbci r29,hi8(-294)
 2045 06e4 1982      		std Y+1,__zero_reg__
 2046 06e6 1882      		st Y,__zero_reg__
 2047 06e8 C652      		subi r28,lo8(294)
 2048 06ea D140      		sbci r29,hi8(294)
1723:stk500boot.c  **** 	myMemoryPtr		=	0;
 2049               		.loc 1 1723 0
 2050 06ec 412C      		mov r4,__zero_reg__
 2051 06ee 512C      		mov r5,__zero_reg__
 2052 06f0 3201      		movw r6,r4
 2053               	.LVL224:
 2054               	.L99:
1731:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
 2055               		.loc 1 1731 0
 2056 06f2 A301      		movw r20,r6
 2057 06f4 9201      		movw r18,r4
 2058 06f6 5695      		lsr r21
 2059 06f8 4795      		ror r20
 2060 06fa 3795      		ror r19
 2061 06fc 2795      		ror r18
 2062 06fe C35D      		subi r28,lo8(-301)
 2063 0700 DE4F      		sbci r29,hi8(-301)
 2064 0702 2883      		st Y,r18
 2065 0704 3983      		std Y+1,r19
 2066 0706 4A83      		std Y+2,r20
 2067 0708 5B83      		std Y+3,r21
 2068 070a CD52      		subi r28,lo8(301)
 2069 070c D140      		sbci r29,hi8(301)
 2070               	.LVL225:
1733:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
 2071               		.loc 1 1733 0
 2072 070e CA5D      		subi r28,lo8(-294)
 2073 0710 DE4F      		sbci r29,hi8(-294)
 2074 0712 4881      		ld r20,Y
 2075 0714 5981      		ldd r21,Y+1
 2076 0716 C652      		subi r28,lo8(294)
 2077 0718 D140      		sbci r29,hi8(294)
 2078 071a 4F5F      		subi r20,-1
 2079 071c 5F4F      		sbci r21,-1
 2080 071e CA5D      		subi r28,lo8(-294)
 2081 0720 DE4F      		sbci r29,hi8(-294)
 2082 0722 5983      		std Y+1,r21
 2083 0724 4883      		st Y,r20
 2084 0726 C652      		subi r28,lo8(294)
 2085 0728 D140      		sbci r29,hi8(294)
 2086 072a 62E0      		ldi r22,lo8(2)
 2087 072c 70E0      		ldi r23,0
 2088 072e CA01      		movw r24,r20
 2089 0730 0E94 0000 		call PrintDecInt
 2090               	.LVL226:
1734:stk500boot.c  **** 		sendchar(0x20);
 2091               		.loc 1 1734 0
 2092 0734 80E2      		ldi r24,lo8(32)
 2093 0736 0E94 0000 		call sendchar
 2094               	.LVL227:
1735:stk500boot.c  **** 		sendchar('-');
 2095               		.loc 1 1735 0
 2096 073a 8DE2      		ldi r24,lo8(45)
 2097 073c 0E94 0000 		call sendchar
 2098               	.LVL228:
1736:stk500boot.c  **** 		sendchar(0x20);
 2099               		.loc 1 1736 0
 2100 0740 80E2      		ldi r24,lo8(32)
 2101 0742 0E94 0000 		call sendchar
 2102               	.LVL229:
1737:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2103               		.loc 1 1737 0
 2104 0746 80E0      		ldi r24,0
 2105 0748 0E94 0000 		call PrintHexByte
 2106               	.LVL230:
1738:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2107               		.loc 1 1738 0
 2108 074c C35D      		subi r28,lo8(-301)
 2109 074e DE4F      		sbci r29,hi8(-301)
 2110 0750 8881      		ld r24,Y
 2111 0752 CD52      		subi r28,lo8(301)
 2112 0754 D140      		sbci r29,hi8(301)
 2113 0756 0E94 0000 		call PrintHexByte
 2114               	.LVL231:
1739:stk500boot.c  **** 		sendchar(0x20);
 2115               		.loc 1 1739 0
 2116 075a 80E2      		ldi r24,lo8(32)
 2117 075c 0E94 0000 		call sendchar
 2118               	.LVL232:
1740:stk500boot.c  **** 		sendchar('=');
 2119               		.loc 1 1740 0
 2120 0760 8DE3      		ldi r24,lo8(61)
 2121 0762 0E94 0000 		call sendchar
 2122               	.LVL233:
1741:stk500boot.c  **** 		sendchar(0x20);
 2123               		.loc 1 1741 0
 2124 0766 80E2      		ldi r24,lo8(32)
 2125 0768 0E94 0000 		call sendchar
 2126               	.LVL234:
 2127               	.LBB171:
1746:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
 2128               		.loc 1 1746 0
 2129               	/* #APP */
 2130               	 ;  1746 "stk500boot.c" 1
 2131 076c 6BBE      		out 59, r6
 2132 076e F201      		movw r30, r4
 2133 0770 0791      		elpm r16, Z+
 2134               		
 2135               	 ;  0 "" 2
 2136               	.LVL235:
 2137               	/* #NOAPP */
 2138 0772 D301      		movw r26,r6
 2139 0774 C201      		movw r24,r4
 2140 0776 0196      		adiw r24,1
 2141 0778 A11D      		adc r26,__zero_reg__
 2142 077a B11D      		adc r27,__zero_reg__
 2143               	.LVL236:
 2144               	.LBE171:
 2145               	.LBB172:
1747:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2146               		.loc 1 1747 0
 2147               	/* #APP */
 2148               	 ;  1747 "stk500boot.c" 1
 2149 077c ABBF      		out 59, r26
 2150 077e FC01      		movw r30, r24
 2151 0780 2791      		elpm r18, Z+
 2152               		
 2153               	 ;  0 "" 2
 2154               	.LVL237:
 2155               	/* #NOAPP */
 2156               	.LBE172:
 2157               	.LBB173:
1748:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2158               		.loc 1 1748 0
 2159 0782 B3E0      		ldi r27,lo8(3)
 2160 0784 8B2E      		mov r8,r27
 2161 0786 912C      		mov r9,__zero_reg__
 2162 0788 A12C      		mov r10,__zero_reg__
 2163 078a B12C      		mov r11,__zero_reg__
 2164 078c 840C      		add r8,r4
 2165 078e 951C      		adc r9,r5
 2166 0790 A61C      		adc r10,r6
 2167 0792 B71C      		adc r11,r7
 2168               	.LVL238:
 2169               	.LBE173:
 2170               	.LBB174:
1747:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2171               		.loc 1 1747 0
 2172 0794 D301      		movw r26,r6
 2173 0796 C201      		movw r24,r4
 2174               	.LVL239:
 2175 0798 0296      		adiw r24,2
 2176 079a A11D      		adc r26,__zero_reg__
 2177 079c B11D      		adc r27,__zero_reg__
 2178               	.LVL240:
 2179               	.LBE174:
 2180               	.LBB175:
1748:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2181               		.loc 1 1748 0
 2182               	/* #APP */
 2183               	 ;  1748 "stk500boot.c" 1
 2184 079e ABBF      		out 59, r26
 2185 07a0 FC01      		movw r30, r24
 2186 07a2 5791      		elpm r21, Z+
 2187               		
 2188               	 ;  0 "" 2
 2189               	/* #NOAPP */
 2190 07a4 C25E      		subi r28,lo8(-286)
 2191 07a6 DE4F      		sbci r29,hi8(-286)
 2192 07a8 5883      		st Y,r21
 2193 07aa CE51      		subi r28,lo8(286)
 2194 07ac D140      		sbci r29,hi8(286)
 2195               	.LVL241:
 2196               	.LBE175:
 2197               	.LBB176:
1749:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2198               		.loc 1 1749 0
 2199 07ae 64E0      		ldi r22,4
 2200 07b0 460E      		add r4,r22
 2201 07b2 511C      		adc r5,__zero_reg__
 2202 07b4 611C      		adc r6,__zero_reg__
 2203 07b6 711C      		adc r7,__zero_reg__
 2204               	.LVL242:
 2205               	/* #APP */
 2206               	 ;  1749 "stk500boot.c" 1
 2207 07b8 ABBE      		out 59, r10
 2208 07ba F401      		movw r30, r8
 2209 07bc 7791      		elpm r23, Z+
 2210               		
 2211               	 ;  0 "" 2
 2212               	/* #NOAPP */
 2213 07be CF5C      		subi r28,lo8(-305)
 2214 07c0 DE4F      		sbci r29,hi8(-305)
 2215 07c2 7883      		st Y,r23
 2216 07c4 C153      		subi r28,lo8(305)
 2217 07c6 D140      		sbci r29,hi8(305)
 2218               	.LVL243:
 2219               	.LBE176:
1747:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2220               		.loc 1 1747 0
 2221 07c8 422F      		mov r20,r18
 2222 07ca 50E0      		ldi r21,0
 2223               	.LVL244:
 2224 07cc 60E0      		ldi r22,0
 2225 07ce 70E0      		ldi r23,0
1756:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
 2226               		.loc 1 1756 0
 2227 07d0 8824      		clr r8
 2228 07d2 942E      		mov r9,r20
 2229 07d4 A52E      		mov r10,r21
 2230 07d6 B62E      		mov r11,r22
 2231               	.LVL245:
 2232 07d8 800E      		add r8,r16
 2233 07da 911C      		adc r9,__zero_reg__
 2234 07dc A11C      		adc r10,__zero_reg__
 2235 07de B11C      		adc r11,__zero_reg__
 2236               	.LVL246:
1760:stk500boot.c  **** 		PrintHexByte(byte2);
 2237               		.loc 1 1760 0
 2238 07e0 822F      		mov r24,r18
 2239 07e2 C65C      		subi r28,lo8(-314)
 2240 07e4 DE4F      		sbci r29,hi8(-314)
 2241 07e6 2883      		st Y,r18
 2242 07e8 CA53      		subi r28,lo8(314)
 2243 07ea D140      		sbci r29,hi8(314)
 2244 07ec 0E94 0000 		call PrintHexByte
 2245               	.LVL247:
1761:stk500boot.c  **** 		sendchar(0x20);
 2246               		.loc 1 1761 0
 2247 07f0 80E2      		ldi r24,lo8(32)
 2248 07f2 0E94 0000 		call sendchar
 2249               	.LVL248:
1762:stk500boot.c  **** 		PrintHexByte(byte1);
 2250               		.loc 1 1762 0
 2251 07f6 802F      		mov r24,r16
 2252 07f8 0E94 0000 		call PrintHexByte
 2253               	.LVL249:
1763:stk500boot.c  **** 		sendchar(0x20);
 2254               		.loc 1 1763 0
 2255 07fc 80E2      		ldi r24,lo8(32)
 2256 07fe 0E94 0000 		call sendchar
 2257               	.LVL250:
1764:stk500boot.c  **** 		PrintHexByte(byte4);
 2258               		.loc 1 1764 0
 2259 0802 CF5C      		subi r28,lo8(-305)
 2260 0804 DE4F      		sbci r29,hi8(-305)
 2261 0806 8881      		ld r24,Y
 2262 0808 C153      		subi r28,lo8(305)
 2263 080a D140      		sbci r29,hi8(305)
 2264 080c 0E94 0000 		call PrintHexByte
 2265               	.LVL251:
1765:stk500boot.c  **** 		sendchar(0x20);
 2266               		.loc 1 1765 0
 2267 0810 80E2      		ldi r24,lo8(32)
 2268 0812 0E94 0000 		call sendchar
 2269               	.LVL252:
1766:stk500boot.c  **** 		PrintHexByte(byte3);
 2270               		.loc 1 1766 0
 2271 0816 C25E      		subi r28,lo8(-286)
 2272 0818 DE4F      		sbci r29,hi8(-286)
 2273 081a 8881      		ld r24,Y
 2274 081c CE51      		subi r28,lo8(286)
 2275 081e D140      		sbci r29,hi8(286)
 2276 0820 0E94 0000 		call PrintHexByte
 2277               	.LVL253:
1767:stk500boot.c  **** 		sendchar(0x20);
 2278               		.loc 1 1767 0
 2279 0824 80E2      		ldi r24,lo8(32)
 2280 0826 0E94 0000 		call sendchar
 2281               	.LVL254:
1769:stk500boot.c  **** 		if (word1 == 0xffff)
 2282               		.loc 1 1769 0
 2283 082a C65C      		subi r28,lo8(-314)
 2284 082c DE4F      		sbci r29,hi8(-314)
 2285 082e 2881      		ld r18,Y
 2286 0830 CA53      		subi r28,lo8(314)
 2287 0832 D140      		sbci r29,hi8(314)
 2288 0834 8FEF      		ldi r24,-1
 2289 0836 8816      		cp r8,r24
 2290 0838 9806      		cpc r9,r24
 2291 083a A104      		cpc r10,__zero_reg__
 2292 083c B104      		cpc r11,__zero_reg__
 2293 083e 01F4      		brne .L96
1771:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
 2294               		.loc 1 1771 0
 2295 0840 60E0      		ldi r22,0
 2296 0842 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2297 0844 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2298 0846 0E94 0000 		call PrintFromPROGMEM
 2299               	.LVL255:
 2300 084a 00C0      		rjmp .L97
 2301               	.L96:
1773:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
 2302               		.loc 1 1773 0
 2303 084c D501      		movw r26,r10
 2304 084e C401      		movw r24,r8
 2305 0850 8827      		clr r24
 2306 0852 907C      		andi r25,192
 2307 0854 AA27      		clr r26
 2308 0856 BB27      		clr r27
 2309 0858 8115      		cp r24,__zero_reg__
 2310 085a 904C      		sbci r25,-64
 2311 085c A105      		cpc r26,__zero_reg__
 2312 085e B105      		cpc r27,__zero_reg__
 2313 0860 01F0      		breq .+2
 2314 0862 00C0      		rjmp .L98
1776:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
 2315               		.loc 1 1776 0
 2316 0864 A501      		movw r20,r10
 2317 0866 9401      		movw r18,r8
 2318 0868 3F73      		andi r19,63
 2319 086a 4427      		clr r20
 2320 086c 5527      		clr r21
 2321 086e C25E      		subi r28,lo8(-286)
 2322 0870 DE4F      		sbci r29,hi8(-286)
 2323 0872 2883      		st Y,r18
 2324 0874 3983      		std Y+1,r19
 2325 0876 4A83      		std Y+2,r20
 2326 0878 5B83      		std Y+3,r21
 2327 087a CE51      		subi r28,lo8(286)
 2328 087c D140      		sbci r29,hi8(286)
 2329               	.LVL256:
1777:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2330               		.loc 1 1777 0
 2331 087e 4901      		movw r8,r18
 2332 0880 5A01      		movw r10,r20
 2333               	.LVL257:
 2334 0882 C35D      		subi r28,lo8(-301)
 2335 0884 DE4F      		sbci r29,hi8(-301)
 2336 0886 4881      		ld r20,Y
 2337 0888 5981      		ldd r21,Y+1
 2338 088a 6A81      		ldd r22,Y+2
 2339 088c 7B81      		ldd r23,Y+3
 2340 088e CD52      		subi r28,lo8(301)
 2341 0890 D140      		sbci r29,hi8(301)
 2342 0892 840E      		add r8,r20
 2343 0894 951E      		adc r9,r21
 2344 0896 A61E      		adc r10,r22
 2345 0898 B71E      		adc r11,r23
 2346               	.LVL258:
1778:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2347               		.loc 1 1778 0
 2348 089a 880C      		lsl r8
 2349 089c 991C      		rol r9
 2350 089e AA1C      		rol r10
 2351 08a0 BB1C      		rol r11
 2352               	.LVL259:
1780:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
 2353               		.loc 1 1780 0
 2354 08a2 60E0      		ldi r22,0
 2355 08a4 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2356 08a6 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2357 08a8 0E94 0000 		call PrintFromPROGMEM
 2358               	.LVL260:
1781:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2359               		.loc 1 1781 0
 2360 08ac C15E      		subi r28,lo8(-287)
 2361 08ae DE4F      		sbci r29,hi8(-287)
 2362 08b0 8881      		ld r24,Y
 2363 08b2 CF51      		subi r28,lo8(287)
 2364 08b4 D140      		sbci r29,hi8(287)
 2365 08b6 0E94 0000 		call PrintHexByte
 2366               	.LVL261:
1782:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2367               		.loc 1 1782 0
 2368 08ba C25E      		subi r28,lo8(-286)
 2369 08bc DE4F      		sbci r29,hi8(-286)
 2370 08be 8881      		ld r24,Y
 2371 08c0 CE51      		subi r28,lo8(286)
 2372 08c2 D140      		sbci r29,hi8(286)
 2373 08c4 0E94 0000 		call PrintHexByte
 2374               	.LVL262:
1783:stk500boot.c  **** 			sendchar(0x20);
 2375               		.loc 1 1783 0
 2376 08c8 80E2      		ldi r24,lo8(32)
 2377 08ca 0E94 0000 		call sendchar
 2378               	.LVL263:
1784:stk500boot.c  **** 			sendchar('>');
 2379               		.loc 1 1784 0
 2380 08ce 8EE3      		ldi r24,lo8(62)
 2381 08d0 0E94 0000 		call sendchar
 2382               	.LVL264:
1785:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2383               		.loc 1 1785 0
 2384 08d4 8A2D      		mov r24,r10
 2385 08d6 0E94 0000 		call PrintHexByte
 2386               	.LVL265:
1786:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2387               		.loc 1 1786 0
 2388 08da 892D      		mov r24,r9
 2389 08dc 0E94 0000 		call PrintHexByte
 2390               	.LVL266:
1787:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2391               		.loc 1 1787 0
 2392 08e0 882D      		mov r24,r8
 2393 08e2 00C0      		rjmp .L245
 2394               	.LVL267:
 2395               	.L98:
1790:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
 2396               		.loc 1 1790 0
 2397 08e4 B501      		movw r22,r10
 2398 08e6 A401      		movw r20,r8
 2399 08e8 4E70      		andi r20,14
 2400 08ea 5E7F      		andi r21,254
 2401 08ec 6627      		clr r22
 2402 08ee 7727      		clr r23
 2403 08f0 4C30      		cpi r20,12
 2404 08f2 5449      		sbci r21,-108
 2405 08f4 6105      		cpc r22,__zero_reg__
 2406 08f6 7105      		cpc r23,__zero_reg__
 2407 08f8 01F0      		breq .+2
 2408 08fa 00C0      		rjmp .L97
1749:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2409               		.loc 1 1749 0
 2410 08fc CF5C      		subi r28,lo8(-305)
 2411 08fe DE4F      		sbci r29,hi8(-305)
 2412 0900 9881      		ld r25,Y
 2413 0902 C153      		subi r28,lo8(305)
 2414 0904 D140      		sbci r29,hi8(305)
 2415 0906 892E      		mov r8,r25
 2416               	.LVL268:
 2417 0908 912C      		mov r9,__zero_reg__
 2418 090a A12C      		mov r10,__zero_reg__
 2419 090c B12C      		mov r11,__zero_reg__
1757:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2420               		.loc 1 1757 0
 2421 090e BA2C      		mov r11,r10
 2422 0910 A92C      		mov r10,r9
 2423 0912 982C      		mov r9,r8
 2424 0914 8824      		clr r8
1793:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 2425               		.loc 1 1793 0
 2426 0916 C25E      		subi r28,lo8(-286)
 2427 0918 DE4F      		sbci r29,hi8(-286)
 2428 091a 3881      		ld r19,Y
 2429 091c CE51      		subi r28,lo8(286)
 2430 091e D140      		sbci r29,hi8(286)
 2431 0920 830E      		add r8,r19
 2432 0922 911C      		adc r9,__zero_reg__
 2433 0924 A11C      		adc r10,__zero_reg__
 2434 0926 B11C      		adc r11,__zero_reg__
 2435               	.LBE170:
 2436 0928 802F      		mov r24,r16
 2437 092a 8170      		andi r24,lo8(1)
 2438               	.LBB177:
 2439 092c 90E0      		ldi r25,0
 2440 092e A0E0      		ldi r26,0
 2441 0930 B0E0      		ldi r27,0
 2442 0932 DC01      		movw r26,r24
 2443 0934 9927      		clr r25
 2444 0936 8827      		clr r24
1794:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2445               		.loc 1 1794 0
 2446 0938 880E      		add r8,r24
 2447 093a 991E      		adc r9,r25
 2448 093c AA1E      		adc r10,r26
 2449 093e BB1E      		adc r11,r27
 2450               	.LBE177:
 2451 0940 802F      		mov r24,r16
 2452 0942 807F      		andi r24,lo8(-16)
 2453               	.LBB178:
 2454 0944 90E0      		ldi r25,0
 2455 0946 A0E0      		ldi r26,0
 2456 0948 B0E0      		ldi r27,0
 2457 094a 41E1      		ldi r20,17
 2458               		1:
 2459 094c 880F      		lsl r24
 2460 094e 991F      		rol r25
 2461 0950 AA1F      		rol r26
 2462 0952 BB1F      		rol r27
 2463 0954 4A95      		dec r20
 2464 0956 01F4      		brne 1b
1757:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2465               		.loc 1 1757 0
 2466 0958 880E      		add r8,r24
 2467 095a 991E      		adc r9,r25
 2468 095c AA1E      		adc r10,r26
 2469 095e BB1E      		adc r11,r27
 2470               	.LBE178:
1795:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2471               		.loc 1 1795 0
 2472 0960 822F      		mov r24,r18
 2473 0962 8170      		andi r24,lo8(1)
 2474               	.LBB179:
 2475 0964 90E0      		ldi r25,0
 2476 0966 A0E0      		ldi r26,0
 2477 0968 B0E0      		ldi r27,0
 2478 096a 55E1      		ldi r21,21
 2479               		1:
 2480 096c 880F      		lsl r24
 2481 096e 991F      		rol r25
 2482 0970 AA1F      		rol r26
 2483 0972 BB1F      		rol r27
 2484 0974 5A95      		dec r21
 2485 0976 01F4      		brne 1b
1793:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
 2486               		.loc 1 1793 0
 2487 0978 880E      		add r8,r24
 2488 097a 991E      		adc r9,r25
 2489 097c AA1E      		adc r10,r26
 2490 097e BB1E      		adc r11,r27
 2491               	.LVL269:
1798:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
 2492               		.loc 1 1798 0
 2493 0980 B501      		movw r22,r10
 2494 0982 A401      		movw r20,r8
 2495 0984 440F      		lsl r20
 2496 0986 551F      		rol r21
 2497 0988 661F      		rol r22
 2498 098a 771F      		rol r23
 2499 098c C25E      		subi r28,lo8(-286)
 2500 098e DE4F      		sbci r29,hi8(-286)
 2501 0990 4883      		st Y,r20
 2502 0992 5983      		std Y+1,r21
 2503 0994 6A83      		std Y+2,r22
 2504 0996 7B83      		std Y+3,r23
 2505 0998 CE51      		subi r28,lo8(286)
 2506 099a D140      		sbci r29,hi8(286)
 2507               	.LVL270:
1800:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
 2508               		.loc 1 1800 0
 2509 099c 60E0      		ldi r22,0
 2510 099e 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2511 09a0 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2512 09a2 0E94 0000 		call PrintFromPROGMEM
 2513               	.LVL271:
1801:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2514               		.loc 1 1801 0
 2515 09a6 8A2D      		mov r24,r10
 2516 09a8 0E94 0000 		call PrintHexByte
 2517               	.LVL272:
1802:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2518               		.loc 1 1802 0
 2519 09ac 892D      		mov r24,r9
 2520 09ae 0E94 0000 		call PrintHexByte
 2521               	.LVL273:
1803:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2522               		.loc 1 1803 0
 2523 09b2 882D      		mov r24,r8
 2524 09b4 0E94 0000 		call PrintHexByte
 2525               	.LVL274:
1804:stk500boot.c  **** 			sendchar(0x20);
 2526               		.loc 1 1804 0
 2527 09b8 80E2      		ldi r24,lo8(32)
 2528 09ba 0E94 0000 		call sendchar
 2529               	.LVL275:
1805:stk500boot.c  **** 			sendchar('>');
 2530               		.loc 1 1805 0
 2531 09be 8EE3      		ldi r24,lo8(62)
 2532 09c0 0E94 0000 		call sendchar
 2533               	.LVL276:
1806:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2534               		.loc 1 1806 0
 2535 09c4 C05E      		subi r28,lo8(-288)
 2536 09c6 DE4F      		sbci r29,hi8(-288)
 2537 09c8 8881      		ld r24,Y
 2538 09ca C052      		subi r28,lo8(288)
 2539 09cc D140      		sbci r29,hi8(288)
 2540 09ce 0E94 0000 		call PrintHexByte
 2541               	.LVL277:
1807:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2542               		.loc 1 1807 0
 2543 09d2 C15E      		subi r28,lo8(-287)
 2544 09d4 DE4F      		sbci r29,hi8(-287)
 2545 09d6 8881      		ld r24,Y
 2546 09d8 CF51      		subi r28,lo8(287)
 2547 09da D140      		sbci r29,hi8(287)
 2548 09dc 0E94 0000 		call PrintHexByte
 2549               	.LVL278:
1808:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2550               		.loc 1 1808 0
 2551 09e0 C25E      		subi r28,lo8(-286)
 2552 09e2 DE4F      		sbci r29,hi8(-286)
 2553 09e4 8881      		ld r24,Y
 2554 09e6 CE51      		subi r28,lo8(286)
 2555 09e8 D140      		sbci r29,hi8(286)
 2556               	.LVL279:
 2557               	.L245:
 2558 09ea 0E94 0000 		call PrintHexByte
 2559               	.LVL280:
 2560               	.L97:
1820:stk500boot.c  **** 		PrintNewLine();
 2561               		.loc 1 1820 0
 2562 09ee 0E94 0000 		call PrintNewLine
 2563               	.LVL281:
1729:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
 2564               		.loc 1 1729 0
 2565 09f2 CA5D      		subi r28,lo8(-294)
 2566 09f4 DE4F      		sbci r29,hi8(-294)
 2567 09f6 2881      		ld r18,Y
 2568 09f8 3981      		ldd r19,Y+1
 2569 09fa C652      		subi r28,lo8(294)
 2570 09fc D140      		sbci r29,hi8(294)
 2571 09fe 2D34      		cpi r18,77
 2572 0a00 3105      		cpc r19,__zero_reg__
 2573 0a02 01F0      		breq .+2
 2574 0a04 00C0      		rjmp .L99
 2575 0a06 00C0      		rjmp .L238
 2576               	.LVL282:
 2577               	.L77:
 2578               	.LBE179:
 2579               	.LBE169:
2186:stk500boot.c  **** 				VectorDisplay();
2187:stk500boot.c  **** 				break;
2188:stk500boot.c  **** 
2189:stk500boot.c  **** 			case 'Y':
2190:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2580               		.loc 1 2190 0
 2581 0a08 62E0      		ldi r22,lo8(2)
 2582 0a0a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2583 0a0c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2584 0a0e 0E94 0000 		call PrintFromPROGMEMln
 2585               	.LVL283:
 2586               	.LBB180:
 2587               	.LBB148:
1894:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
 2588               		.loc 1 1894 0
 2589 0a12 60E0      		ldi r22,0
 2590 0a14 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2591 0a16 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2592 0a18 0E94 0000 		call PrintFromPROGMEM
 2593               	.LVL284:
1896:stk500boot.c  **** 	portLetter	=	recchar();
 2594               		.loc 1 1896 0
 2595 0a1c 0E94 0000 		call recchar
 2596               	.LVL285:
1897:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2597               		.loc 1 1897 0
 2598 0a20 082F      		mov r16,r24
 2599               	.LVL286:
 2600 0a22 0F75      		andi r16,lo8(95)
 2601               	.LVL287:
1898:stk500boot.c  **** 	sendchar(portLetter);
 2602               		.loc 1 1898 0
 2603 0a24 802F      		mov r24,r16
 2604 0a26 0E94 0000 		call sendchar
 2605               	.LVL288:
1899:stk500boot.c  **** 	PrintNewLine();
 2606               		.loc 1 1899 0
 2607 0a2a 0E94 0000 		call PrintNewLine
 2608               	.LVL289:
1901:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
 2609               		.loc 1 1901 0
 2610 0a2e 802F      		mov r24,r16
 2611 0a30 8154      		subi r24,lo8(-(-65))
 2612 0a32 8A31      		cpi r24,lo8(26)
 2613 0a34 00F0      		brlo .+2
 2614 0a36 00C0      		rjmp .L100
 2615               	.LVL290:
1904:stk500boot.c  **** 		switch(portLetter)
 2616               		.loc 1 1904 0
 2617 0a38 0434      		cpi r16,lo8(68)
 2618 0a3a 01F0      		breq .L105
 2619 0a3c 00F4      		brsh .L109
 2620 0a3e 0234      		cpi r16,lo8(66)
 2621 0a40 01F0      		breq .L103
 2622 0a42 00F4      		brsh .L104
 2623 0a44 0134      		cpi r16,lo8(65)
 2624 0a46 01F0      		breq .+2
 2625 0a48 00C0      		rjmp .L101
 2626 0a4a 00C0      		rjmp .L102
 2627               	.L109:
 2628 0a4c 0634      		cpi r16,lo8(70)
 2629 0a4e 01F4      		brne .+2
 2630 0a50 00C0      		rjmp .L107
 2631 0a52 00F4      		brsh .+2
 2632 0a54 00C0      		rjmp .L106
 2633 0a56 0734      		cpi r16,lo8(71)
 2634 0a58 01F0      		breq .+2
 2635 0a5a 00C0      		rjmp .L101
 2636 0a5c 00C0      		rjmp .L108
 2637               	.L102:
1908:stk500boot.c  **** 				DDRA	=	0xff;
 2638               		.loc 1 1908 0
 2639 0a5e 11B9      		out 0x1,r17
 2640 0a60 00C0      		rjmp .L110
 2641               	.L111:
1911:stk500boot.c  **** 					PORTA	^=	0xff;
 2642               		.loc 1 1911 0
 2643 0a62 82B1      		in r24,0x2
 2644 0a64 8095      		com r24
 2645 0a66 82B9      		out 0x2,r24
1912:stk500boot.c  **** 					delay_ms(200);
 2646               		.loc 1 1912 0
 2647 0a68 88EC      		ldi r24,lo8(-56)
 2648 0a6a 90E0      		ldi r25,0
 2649 0a6c 0E94 0000 		call delay_ms
 2650               	.LVL291:
 2651               	.L110:
 2652               	.LBB134:
 2653               	.LBB135:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2654               		.loc 1 506 0
 2655 0a70 8091 C000 		lds r24,192
 2656               	.LBE135:
 2657               	.LBE134:
1909:stk500boot.c  **** 				while (!Serial_Available())
 2658               		.loc 1 1909 0
 2659 0a74 87FF      		sbrs r24,7
 2660 0a76 00C0      		rjmp .L111
1914:stk500boot.c  **** 				PORTA	=	0;
 2661               		.loc 1 1914 0
 2662 0a78 12B8      		out 0x2,__zero_reg__
 2663 0a7a 00C0      		rjmp .L112
 2664               	.L103:
1920:stk500boot.c  **** 				DDRB	=	0xff;
 2665               		.loc 1 1920 0
 2666 0a7c 14B9      		out 0x4,r17
 2667 0a7e 00C0      		rjmp .L113
 2668               	.L114:
1923:stk500boot.c  **** 					PORTB	^=	0xff;
 2669               		.loc 1 1923 0
 2670 0a80 85B1      		in r24,0x5
 2671 0a82 8095      		com r24
 2672 0a84 85B9      		out 0x5,r24
1924:stk500boot.c  **** 					delay_ms(200);
 2673               		.loc 1 1924 0
 2674 0a86 88EC      		ldi r24,lo8(-56)
 2675 0a88 90E0      		ldi r25,0
 2676 0a8a 0E94 0000 		call delay_ms
 2677               	.LVL292:
 2678               	.L113:
 2679               	.LBB136:
 2680               	.LBB137:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2681               		.loc 1 506 0
 2682 0a8e 8091 C000 		lds r24,192
 2683               	.LBE137:
 2684               	.LBE136:
1921:stk500boot.c  **** 				while (!Serial_Available())
 2685               		.loc 1 1921 0
 2686 0a92 87FF      		sbrs r24,7
 2687 0a94 00C0      		rjmp .L114
1926:stk500boot.c  **** 				PORTB	=	0;
 2688               		.loc 1 1926 0
 2689 0a96 15B8      		out 0x5,__zero_reg__
 2690 0a98 00C0      		rjmp .L112
 2691               	.L104:
1932:stk500boot.c  **** 				DDRC	=	0xff;
 2692               		.loc 1 1932 0
 2693 0a9a 17B9      		out 0x7,r17
 2694 0a9c 00C0      		rjmp .L115
 2695               	.L116:
1935:stk500boot.c  **** 					PORTC	^=	0xff;
 2696               		.loc 1 1935 0
 2697 0a9e 88B1      		in r24,0x8
 2698 0aa0 8095      		com r24
 2699 0aa2 88B9      		out 0x8,r24
1936:stk500boot.c  **** 					delay_ms(200);
 2700               		.loc 1 1936 0
 2701 0aa4 88EC      		ldi r24,lo8(-56)
 2702 0aa6 90E0      		ldi r25,0
 2703 0aa8 0E94 0000 		call delay_ms
 2704               	.LVL293:
 2705               	.L115:
 2706               	.LBB138:
 2707               	.LBB139:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2708               		.loc 1 506 0
 2709 0aac 8091 C000 		lds r24,192
 2710               	.LBE139:
 2711               	.LBE138:
1933:stk500boot.c  **** 				while (!Serial_Available())
 2712               		.loc 1 1933 0
 2713 0ab0 87FF      		sbrs r24,7
 2714 0ab2 00C0      		rjmp .L116
1938:stk500boot.c  **** 				PORTC	=	0;
 2715               		.loc 1 1938 0
 2716 0ab4 18B8      		out 0x8,__zero_reg__
 2717 0ab6 00C0      		rjmp .L112
 2718               	.L105:
1944:stk500boot.c  **** 				DDRD	=	0xff;
 2719               		.loc 1 1944 0
 2720 0ab8 1AB9      		out 0xa,r17
 2721 0aba 00C0      		rjmp .L117
 2722               	.L118:
1947:stk500boot.c  **** 					PORTD	^=	0xff;
 2723               		.loc 1 1947 0
 2724 0abc 8BB1      		in r24,0xb
 2725 0abe 8095      		com r24
 2726 0ac0 8BB9      		out 0xb,r24
1948:stk500boot.c  **** 					delay_ms(200);
 2727               		.loc 1 1948 0
 2728 0ac2 88EC      		ldi r24,lo8(-56)
 2729 0ac4 90E0      		ldi r25,0
 2730 0ac6 0E94 0000 		call delay_ms
 2731               	.LVL294:
 2732               	.L117:
 2733               	.LBB140:
 2734               	.LBB141:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2735               		.loc 1 506 0
 2736 0aca 8091 C000 		lds r24,192
 2737               	.LBE141:
 2738               	.LBE140:
1945:stk500boot.c  **** 				while (!Serial_Available())
 2739               		.loc 1 1945 0
 2740 0ace 87FF      		sbrs r24,7
 2741 0ad0 00C0      		rjmp .L118
1950:stk500boot.c  **** 				PORTD	=	0;
 2742               		.loc 1 1950 0
 2743 0ad2 1BB8      		out 0xb,__zero_reg__
 2744 0ad4 00C0      		rjmp .L112
 2745               	.L106:
1956:stk500boot.c  **** 				DDRE	=	0xff;
 2746               		.loc 1 1956 0
 2747 0ad6 1DB9      		out 0xd,r17
 2748 0ad8 00C0      		rjmp .L119
 2749               	.L120:
1959:stk500boot.c  **** 					PORTE	^=	0xff;
 2750               		.loc 1 1959 0
 2751 0ada 8EB1      		in r24,0xe
 2752 0adc 8095      		com r24
 2753 0ade 8EB9      		out 0xe,r24
1960:stk500boot.c  **** 					delay_ms(200);
 2754               		.loc 1 1960 0
 2755 0ae0 88EC      		ldi r24,lo8(-56)
 2756 0ae2 90E0      		ldi r25,0
 2757 0ae4 0E94 0000 		call delay_ms
 2758               	.LVL295:
 2759               	.L119:
 2760               	.LBB142:
 2761               	.LBB143:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2762               		.loc 1 506 0
 2763 0ae8 8091 C000 		lds r24,192
 2764               	.LBE143:
 2765               	.LBE142:
1957:stk500boot.c  **** 				while (!Serial_Available())
 2766               		.loc 1 1957 0
 2767 0aec 87FF      		sbrs r24,7
 2768 0aee 00C0      		rjmp .L120
1962:stk500boot.c  **** 				PORTE	=	0;
 2769               		.loc 1 1962 0
 2770 0af0 1EB8      		out 0xe,__zero_reg__
 2771 0af2 00C0      		rjmp .L112
 2772               	.L107:
1968:stk500boot.c  **** 				DDRF	=	0xff;
 2773               		.loc 1 1968 0
 2774 0af4 10BB      		out 0x10,r17
 2775 0af6 00C0      		rjmp .L121
 2776               	.L122:
1971:stk500boot.c  **** 					PORTF	^=	0xff;
 2777               		.loc 1 1971 0
 2778 0af8 81B3      		in r24,0x11
 2779 0afa 8095      		com r24
 2780 0afc 81BB      		out 0x11,r24
1972:stk500boot.c  **** 					delay_ms(200);
 2781               		.loc 1 1972 0
 2782 0afe 88EC      		ldi r24,lo8(-56)
 2783 0b00 90E0      		ldi r25,0
 2784 0b02 0E94 0000 		call delay_ms
 2785               	.LVL296:
 2786               	.L121:
 2787               	.LBB144:
 2788               	.LBB145:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2789               		.loc 1 506 0
 2790 0b06 8091 C000 		lds r24,192
 2791               	.LBE145:
 2792               	.LBE144:
1969:stk500boot.c  **** 				while (!Serial_Available())
 2793               		.loc 1 1969 0
 2794 0b0a 87FF      		sbrs r24,7
 2795 0b0c 00C0      		rjmp .L122
1974:stk500boot.c  **** 				PORTF	=	0;
 2796               		.loc 1 1974 0
 2797 0b0e 11BA      		out 0x11,__zero_reg__
 2798 0b10 00C0      		rjmp .L112
 2799               	.L108:
1980:stk500boot.c  **** 				DDRG	=	0xff;
 2800               		.loc 1 1980 0
 2801 0b12 13BB      		out 0x13,r17
 2802 0b14 00C0      		rjmp .L123
 2803               	.L124:
1983:stk500boot.c  **** 					PORTG	^=	0xff;
 2804               		.loc 1 1983 0
 2805 0b16 84B3      		in r24,0x14
 2806 0b18 8095      		com r24
 2807 0b1a 84BB      		out 0x14,r24
1984:stk500boot.c  **** 					delay_ms(200);
 2808               		.loc 1 1984 0
 2809 0b1c 88EC      		ldi r24,lo8(-56)
 2810 0b1e 90E0      		ldi r25,0
 2811 0b20 0E94 0000 		call delay_ms
 2812               	.LVL297:
 2813               	.L123:
 2814               	.LBB146:
 2815               	.LBB147:
 506:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 2816               		.loc 1 506 0
 2817 0b24 8091 C000 		lds r24,192
 2818               	.LBE147:
 2819               	.LBE146:
1981:stk500boot.c  **** 				while (!Serial_Available())
 2820               		.loc 1 1981 0
 2821 0b28 87FF      		sbrs r24,7
 2822 0b2a 00C0      		rjmp .L124
1986:stk500boot.c  **** 				PORTG	=	0;
 2823               		.loc 1 1986 0
 2824 0b2c 14BA      		out 0x14,__zero_reg__
 2825 0b2e 00C0      		rjmp .L112
 2826               	.L101:
2051:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
 2827               		.loc 1 2051 0
 2828 0b30 60E0      		ldi r22,0
 2829 0b32 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2830 0b34 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2831 0b36 00C0      		rjmp .L243
 2832               	.LVL298:
 2833               	.L100:
2062:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
 2834               		.loc 1 2062 0
 2835 0b38 60E0      		ldi r22,0
 2836 0b3a 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2837 0b3c 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2838 0b3e 00C0      		rjmp .L243
 2839               	.LVL299:
 2840               	.L65:
 2841               	.LBE148:
 2842               	.LBE180:
2191:stk500boot.c  **** 				AVR_PortOutput();
2192:stk500boot.c  **** 				break;
2193:stk500boot.c  **** 			
2194:stk500boot.c  **** 			default:
2195:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2843               		.loc 1 2195 0
 2844 0b40 60E0      		ldi r22,0
 2845 0b42 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2846 0b44 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2847               	.LVL300:
 2848               	.L243:
 2849 0b46 0E94 0000 		call PrintFromPROGMEMln
 2850               	.LVL301:
 2851 0b4a 00C0      		rjmp .L238
 2852               	.LVL302:
 2853               	.L184:
 2854               	.LBE181:
 2855               	.LBE182:
 781:stk500boot.c  **** 					exPointCntr	=	0;
 2856               		.loc 1 781 0
 2857 0b4c 612C      		mov r6,__zero_reg__
 2858 0b4e 712C      		mov r7,__zero_reg__
 2859               	.LVL303:
 2860               	.L58:
 785:stk500boot.c  **** 				switch (msgParseState)
 2861               		.loc 1 785 0
 2862 0b50 8330      		cpi r24,lo8(3)
 2863 0b52 01F0      		breq .L129
 2864 0b54 00F4      		brsh .L133
 2865 0b56 8130      		cpi r24,lo8(1)
 2866 0b58 01F0      		breq .L127
 2867 0b5a 00F4      		brsh .L128
 2868 0b5c 00C0      		rjmp .L240
 2869               	.L133:
 2870 0b5e 8530      		cpi r24,lo8(5)
 2871 0b60 01F0      		breq .L131
 2872 0b62 00F0      		brlo .L130
 2873 0b64 8630      		cpi r24,lo8(6)
 2874 0b66 01F4      		brne .L241
 2875 0b68 00C0      		rjmp .L132
 2876               	.L240:
 788:stk500boot.c  **** 						if ( c == MESSAGE_START )
 2877               		.loc 1 788 0
 2878 0b6a 9B31      		cpi r25,lo8(27)
 2879 0b6c 01F0      		breq .+2
 2880 0b6e 00C0      		rjmp .L135
 2881 0b70 00C0      		rjmp .L185
 2882               	.L127:
 2883               	.LVL304:
 801:stk500boot.c  **** 						checksum		^=	c;
 2884               		.loc 1 801 0
 2885 0b72 9926      		eor r9,r25
 2886               	.LVL305:
 814:stk500boot.c  **** 						break;
 2887               		.loc 1 814 0
 2888 0b74 C65D      		subi r28,lo8(-298)
 2889 0b76 DE4F      		sbci r29,hi8(-298)
 2890 0b78 9883      		st Y,r25
 2891 0b7a CA52      		subi r28,lo8(298)
 2892 0b7c D140      		sbci r29,hi8(298)
 800:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 2893               		.loc 1 800 0
 2894 0b7e 82E0      		ldi r24,lo8(2)
 814:stk500boot.c  **** 						break;
 2895               		.loc 1 814 0
 2896 0b80 00C0      		rjmp .L135
 2897               	.LVL306:
 2898               	.L128:
 817:stk500boot.c  **** 						msgLength		=	c<<8;
 2899               		.loc 1 817 0
 2900 0b82 392F      		mov r19,r25
 2901 0b84 20E0      		ldi r18,0
 2902               	.LVL307:
 819:stk500boot.c  **** 						checksum		^=	c;
 2903               		.loc 1 819 0
 2904 0b86 9926      		eor r9,r25
 2905               	.LVL308:
 818:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2906               		.loc 1 818 0
 2907 0b88 83E0      		ldi r24,lo8(3)
 820:stk500boot.c  **** 						break;
 2908               		.loc 1 820 0
 2909 0b8a 00C0      		rjmp .L135
 2910               	.LVL309:
 2911               	.L129:
 823:stk500boot.c  **** 						msgLength		|=	c;
 2912               		.loc 1 823 0
 2913 0b8c 292B      		or r18,r25
 2914               	.LVL310:
 825:stk500boot.c  **** 						checksum		^=	c;
 2915               		.loc 1 825 0
 2916 0b8e 9926      		eor r9,r25
 2917               	.LVL311:
 824:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2918               		.loc 1 824 0
 2919 0b90 84E0      		ldi r24,lo8(4)
 826:stk500boot.c  **** 						break;
 2920               		.loc 1 826 0
 2921 0b92 00C0      		rjmp .L135
 2922               	.LVL312:
 2923               	.L130:
 829:stk500boot.c  **** 						if ( c == TOKEN )
 2924               		.loc 1 829 0
 2925 0b94 9E30      		cpi r25,lo8(14)
 2926 0b96 01F0      		breq .+2
 2927 0b98 00C0      		rjmp .L186
 2928               	.LVL313:
 832:stk500boot.c  **** 							checksum		^=	c;
 2929               		.loc 1 832 0
 2930 0b9a 9926      		eor r9,r25
 2931               	.LVL314:
 833:stk500boot.c  **** 							ii				=	0;
 2932               		.loc 1 833 0
 2933 0b9c 212C      		mov r2,__zero_reg__
 2934 0b9e 312C      		mov r3,__zero_reg__
 831:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 2935               		.loc 1 831 0
 2936 0ba0 85E0      		ldi r24,lo8(5)
 2937 0ba2 00C0      		rjmp .L135
 2938               	.LVL315:
 2939               	.L131:
 842:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 2940               		.loc 1 842 0
 2941 0ba4 E1E0      		ldi r30,lo8(1)
 2942 0ba6 F0E0      		ldi r31,0
 2943 0ba8 EC0F      		add r30,r28
 2944 0baa FD1F      		adc r31,r29
 2945 0bac E20D      		add r30,r2
 2946 0bae F31D      		adc r31,r3
 2947 0bb0 9083      		st Z,r25
 2948 0bb2 4FEF      		ldi r20,-1
 2949 0bb4 241A      		sub r2,r20
 2950 0bb6 340A      		sbc r3,r20
 2951               	.LVL316:
 843:stk500boot.c  **** 						checksum		^=	c;
 2952               		.loc 1 843 0
 2953 0bb8 9926      		eor r9,r25
 2954               	.LVL317:
 844:stk500boot.c  **** 						if (ii == msgLength )
 2955               		.loc 1 844 0
 2956 0bba 2216      		cp r2,r18
 2957 0bbc 3306      		cpc r3,r19
 2958 0bbe 01F0      		breq .+2
 2959 0bc0 00C0      		rjmp .L135
 2960 0bc2 00C0      		rjmp .L187
 2961               	.LVL318:
 2962               	.L132:
 851:stk500boot.c  **** 						if ( c == checksum )
 2963               		.loc 1 851 0
 2964 0bc4 9915      		cp r25,r9
 2965 0bc6 01F0      		breq .L188
 2966 0bc8 00C0      		rjmp .L186
 2967               	.L241:
 2968               	.LVL319:
 749:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 2969               		.loc 1 749 0 discriminator 1
 2970 0bca 8730      		cpi r24,lo8(7)
 2971 0bcc 01F0      		breq .+2
 2972 0bce 00C0      		rjmp .L135
 2973               	.LVL320:
 2974               	.L188:
 851:stk500boot.c  **** 						if ( c == checksum )
 2975               		.loc 1 851 0
 2976 0bd0 512C      		mov r5,__zero_reg__
 2977               	.LVL321:
 2978               	.L95:
 867:stk500boot.c  **** 			switch (msgBuffer[0])
 2979               		.loc 1 867 0
 2980 0bd2 2981      		ldd r18,Y+1
 2981 0bd4 2331      		cpi r18,lo8(19)
 2982 0bd6 01F4      		brne .+2
 2983 0bd8 00C0      		rjmp .L143
 2984 0bda 00F4      		brsh .L150
 2985 0bdc 2630      		cpi r18,lo8(6)
 2986 0bde 01F4      		brne .+2
 2987 0be0 00C0      		rjmp .L140
 2988 0be2 00F4      		brsh .L151
 2989 0be4 2230      		cpi r18,lo8(2)
 2990 0be6 01F4      		brne .+2
 2991 0be8 00C0      		rjmp .L252
 2992 0bea 2330      		cpi r18,lo8(3)
 2993 0bec 01F4      		brne .+2
 2994 0bee 00C0      		rjmp .L139
 2995 0bf0 2130      		cpi r18,lo8(1)
 2996 0bf2 01F0      		breq .+2
 2997 0bf4 00C0      		rjmp .L136
 2998 0bf6 00C0      		rjmp .L137
 2999               	.L151:
 3000 0bf8 2131      		cpi r18,lo8(17)
 3001 0bfa 01F4      		brne .+2
 3002 0bfc 00C0      		rjmp .L189
 3003 0bfe 00F0      		brlo .+2
 3004 0c00 00C0      		rjmp .L142
 3005 0c02 2031      		cpi r18,lo8(16)
 3006 0c04 01F0      		breq .+2
 3007 0c06 00C0      		rjmp .L136
 3008 0c08 00C0      		rjmp .L252
 3009               	.L150:
 3010 0c0a 2831      		cpi r18,lo8(24)
 3011 0c0c 01F4      		brne .+2
 3012 0c0e 00C0      		rjmp .L145
 3013 0c10 00F4      		brsh .L152
 3014 0c12 2531      		cpi r18,lo8(21)
 3015 0c14 01F4      		brne .+2
 3016 0c16 00C0      		rjmp .L143
 3017 0c18 00F4      		brsh .+2
 3018 0c1a 00C0      		rjmp .L144
 3019 0c1c 2631      		cpi r18,lo8(22)
 3020 0c1e 01F0      		breq .+2
 3021 0c20 00C0      		rjmp .L136
 3022 0c22 00C0      		rjmp .L144
 3023               	.L152:
 3024 0c24 2A31      		cpi r18,lo8(26)
 3025 0c26 01F4      		brne .+2
 3026 0c28 00C0      		rjmp .L147
 3027 0c2a 00F4      		brsh .+2
 3028 0c2c 00C0      		rjmp .L146
 3029 0c2e 2B31      		cpi r18,lo8(27)
 3030 0c30 01F4      		brne .+2
 3031 0c32 00C0      		rjmp .L148
 3032 0c34 2D31      		cpi r18,lo8(29)
 3033 0c36 01F0      		breq .+2
 3034 0c38 00C0      		rjmp .L136
 3035               	.LVL322:
 3036               	.LBB183:
 875:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 3037               		.loc 1 875 0
 3038 0c3a 8D81      		ldd r24,Y+5
 3039 0c3c 8033      		cpi r24,lo8(48)
 3040 0c3e 01F4      		brne .L153
 3041               	.LBB184:
 877:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 3042               		.loc 1 877 0
 3043 0c40 9F81      		ldd r25,Y+7
 3044               	.LVL323:
 879:stk500boot.c  **** 							if ( signatureIndex == 0 )
 3045               		.loc 1 879 0
 3046 0c42 9923      		tst r25
 3047 0c44 01F0      		breq .L190
 883:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 3048               		.loc 1 883 0
 3049 0c46 9130      		cpi r25,lo8(1)
 3050 0c48 01F4      		brne .L191
 885:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3051               		.loc 1 885 0
 3052 0c4a E8EA      		ldi r30,lo8(-88)
 3053 0c4c 00C0      		rjmp .L154
 3054               	.LVL324:
 3055               	.L153:
 3056               	.LBE184:
 892:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 3057               		.loc 1 892 0
 3058 0c4e 982F      		mov r25,r24
 3059 0c50 9075      		andi r25,lo8(80)
 3060 0c52 01F0      		breq .L193
 899:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 3061               		.loc 1 899 0
 3062 0c54 8035      		cpi r24,lo8(80)
 3063 0c56 01F4      		brne .L155
 3064               	.LBB185:
 901:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 3065               		.loc 1 901 0
 3066 0c58 E0E0      		ldi r30,0
 3067 0c5a F0E0      		ldi r31,0
 3068 0c5c 00C0      		rjmp .L246
 3069               	.L155:
 3070               	.LBE185:
 903:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 3071               		.loc 1 903 0
 3072 0c5e 8835      		cpi r24,lo8(88)
 3073 0c60 01F4      		brne .L193
 3074               	.LBB186:
 905:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 3075               		.loc 1 905 0
 3076 0c62 E3E0      		ldi r30,lo8(3)
 3077 0c64 F0E0      		ldi r31,0
 3078               	.L246:
 3079 0c66 99E0      		ldi r25,lo8(9)
 3080               	/* #APP */
 3081               	 ;  905 "stk500boot.c" 1
 3082 0c68 9093 5700 		sts 87, r25
 3083 0c6c E491      		lpm r30, Z
 3084               		
 3085               	 ;  0 "" 2
 3086               	.LVL325:
 3087               	/* #NOAPP */
 3088 0c6e 00C0      		rjmp .L154
 3089               	.LVL326:
 3090               	.L190:
 3091               	.LBE186:
 3092               	.LBB187:
 881:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 3093               		.loc 1 881 0
 3094 0c70 EEE1      		ldi r30,lo8(30)
 3095 0c72 00C0      		rjmp .L154
 3096               	.L191:
 889:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 3097               		.loc 1 889 0
 3098 0c74 E3E0      		ldi r30,lo8(3)
 3099 0c76 00C0      		rjmp .L154
 3100               	.LVL327:
 3101               	.L193:
 3102               	.LBE187:
 909:stk500boot.c  **** 								answerByte	=	0;
 3103               		.loc 1 909 0
 3104 0c78 E0E0      		ldi r30,0
 3105               	.L154:
 3106               	.LVL328:
 919:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3107               		.loc 1 919 0
 3108 0c7a 1A82      		std Y+2,__zero_reg__
 920:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3109               		.loc 1 920 0
 3110 0c7c 1B82      		std Y+3,__zero_reg__
 921:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3111               		.loc 1 921 0
 3112 0c7e 8C83      		std Y+4,r24
 922:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3113               		.loc 1 922 0
 3114 0c80 1D82      		std Y+5,__zero_reg__
 923:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3115               		.loc 1 923 0
 3116 0c82 EE83      		std Y+6,r30
 924:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3117               		.loc 1 924 0
 3118 0c84 1F82      		std Y+7,__zero_reg__
 918:stk500boot.c  **** 							msgLength		=	7;
 3119               		.loc 1 918 0
 3120 0c86 07E0      		ldi r16,lo8(7)
 3121 0c88 10E0      		ldi r17,0
 3122 0c8a 00C0      		rjmp .L156
 3123               	.LVL329:
 3124               	.L137:
 3125               	.LBE183:
 931:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 3126               		.loc 1 931 0
 3127 0c8c 1A82      		std Y+2,__zero_reg__
 932:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 3128               		.loc 1 932 0
 3129 0c8e 88E0      		ldi r24,lo8(8)
 3130 0c90 8B83      		std Y+3,r24
 933:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 3131               		.loc 1 933 0
 3132 0c92 81E4      		ldi r24,lo8(65)
 3133 0c94 8C83      		std Y+4,r24
 934:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 3134               		.loc 1 934 0
 3135 0c96 86E5      		ldi r24,lo8(86)
 3136 0c98 8D83      		std Y+5,r24
 935:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 3137               		.loc 1 935 0
 3138 0c9a 82E5      		ldi r24,lo8(82)
 3139 0c9c 8E83      		std Y+6,r24
 936:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 3140               		.loc 1 936 0
 3141 0c9e 89E4      		ldi r24,lo8(73)
 3142 0ca0 8F83      		std Y+7,r24
 937:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 3143               		.loc 1 937 0
 3144 0ca2 83E5      		ldi r24,lo8(83)
 3145 0ca4 8887      		std Y+8,r24
 938:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 3146               		.loc 1 938 0
 3147 0ca6 80E5      		ldi r24,lo8(80)
 3148 0ca8 8987      		std Y+9,r24
 939:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 3149               		.loc 1 939 0
 3150 0caa 8FE5      		ldi r24,lo8(95)
 3151 0cac 8A87      		std Y+10,r24
 940:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 3152               		.loc 1 940 0
 3153 0cae 82E3      		ldi r24,lo8(50)
 3154 0cb0 8B87      		std Y+11,r24
 930:stk500boot.c  **** 					msgLength		=	11;
 3155               		.loc 1 930 0
 3156 0cb2 0BE0      		ldi r16,lo8(11)
 3157 0cb4 10E0      		ldi r17,0
 941:stk500boot.c  **** 					break;
 3158               		.loc 1 941 0
 3159 0cb6 00C0      		rjmp .L156
 3160               	.LVL330:
 3161               	.L139:
 3162 0cb8 EA81      		ldd r30,Y+2
 3163 0cba E059      		subi r30,lo8(-(112))
 3164 0cbc E330      		cpi r30,lo8(3)
 3165 0cbe 00F4      		brsh .L194
 3166 0cc0 F0E0      		ldi r31,0
 3167 0cc2 E050      		subi r30,lo8(-(CSWTCH.54))
 3168 0cc4 F040      		sbci r31,hi8(-(CSWTCH.54))
 3169 0cc6 8081      		ld r24,Z
 3170 0cc8 00C0      		rjmp .L157
 3171               	.L194:
 3172               	.LBB188:
 947:stk500boot.c  **** 						switch(msgBuffer[1])
 3173               		.loc 1 947 0
 3174 0cca 80E0      		ldi r24,0
 3175               	.L157:
 3176               	.LVL331:
 969:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3177               		.loc 1 969 0
 3178 0ccc 1A82      		std Y+2,__zero_reg__
 970:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3179               		.loc 1 970 0
 3180 0cce 8B83      		std Y+3,r24
 3181 0cd0 00C0      		rjmp .L248
 3182               	.LVL332:
 3183               	.L189:
 3184               	.LBE188:
 975:stk500boot.c  **** 					isLeave	=	1;
 3185               		.loc 1 975 0
 3186 0cd2 5524      		clr r5
 3187 0cd4 5394      		inc r5
 3188               	.LVL333:
 3189 0cd6 00C0      		rjmp .L252
 3190               	.LVL334:
 3191               	.L148:
 3192               	.LBB189:
 986:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 3193               		.loc 1 986 0
 3194 0cd8 8D81      		ldd r24,Y+5
 3195               	.LVL335:
 989:stk500boot.c  **** 						if ( signatureIndex == 0 )
 3196               		.loc 1 989 0
 3197 0cda 8823      		tst r24
 3198 0cdc 01F0      		breq .L195
 991:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3199               		.loc 1 991 0
 3200 0cde 8130      		cpi r24,lo8(1)
 3201 0ce0 01F4      		brne .L196
 992:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3202               		.loc 1 992 0
 3203 0ce2 88EA      		ldi r24,lo8(-88)
 3204               	.LVL336:
 3205 0ce4 00C0      		rjmp .L158
 3206               	.LVL337:
 3207               	.L195:
 990:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3208               		.loc 1 990 0
 3209 0ce6 8EE1      		ldi r24,lo8(30)
 3210               	.LVL338:
 3211 0ce8 00C0      		rjmp .L158
 3212               	.LVL339:
 3213               	.L196:
 994:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 3214               		.loc 1 994 0
 3215 0cea 83E0      		ldi r24,lo8(3)
 3216               	.LVL340:
 3217               	.L158:
 997:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3218               		.loc 1 997 0
 3219 0cec 1A82      		std Y+2,__zero_reg__
 998:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 3220               		.loc 1 998 0
 3221 0cee 8B83      		std Y+3,r24
 3222 0cf0 00C0      		rjmp .L250
 3223               	.LVL341:
 3224               	.L147:
 3225               	.LBE189:
1005:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3226               		.loc 1 1005 0
 3227 0cf2 1A82      		std Y+2,__zero_reg__
 3228               	.LBB190:
1006:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3229               		.loc 1 1006 0
 3230 0cf4 E1E0      		ldi r30,lo8(1)
 3231 0cf6 F0E0      		ldi r31,0
 3232 0cf8 89E0      		ldi r24,lo8(9)
 3233               	/* #APP */
 3234               	 ;  1006 "stk500boot.c" 1
 3235 0cfa 8093 5700 		sts 87, r24
 3236 0cfe E491      		lpm r30, Z
 3237               		
 3238               	 ;  0 "" 2
 3239               	/* #NOAPP */
 3240               	.L251:
 3241               	.LVL342:
 3242               	.LBE190:
 3243 0d00 EB83      		std Y+3,r30
 3244               	.LVL343:
 3245               	.L250:
1007:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3246               		.loc 1 1007 0
 3247 0d02 1C82      		std Y+4,__zero_reg__
1004:stk500boot.c  **** 					msgLength		=	4;
 3248               		.loc 1 1004 0
 3249 0d04 04E0      		ldi r16,lo8(4)
 3250 0d06 10E0      		ldi r17,0
1008:stk500boot.c  **** 					break;
 3251               		.loc 1 1008 0
 3252 0d08 00C0      		rjmp .L156
 3253               	.LVL344:
 3254               	.L145:
 3255               	.LBB191:
1014:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 3256               		.loc 1 1014 0
 3257 0d0a 8B81      		ldd r24,Y+3
 3258 0d0c 8035      		cpi r24,lo8(80)
 3259 0d0e 01F4      		brne .L159
1016:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 3260               		.loc 1 1016 0
 3261 0d10 8C81      		ldd r24,Y+4
 3262 0d12 8830      		cpi r24,lo8(8)
 3263 0d14 01F4      		brne .L160
 3264               	.LBB192:
1017:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3265               		.loc 1 1017 0
 3266 0d16 E2E0      		ldi r30,lo8(2)
 3267 0d18 F0E0      		ldi r31,0
 3268 0d1a 00C0      		rjmp .L247
 3269               	.L160:
 3270               	.LBE192:
 3271               	.LBB193:
1019:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 3272               		.loc 1 1019 0
 3273 0d1c E0E0      		ldi r30,0
 3274 0d1e F0E0      		ldi r31,0
 3275 0d20 00C0      		rjmp .L247
 3276               	.L159:
 3277               	.LBE193:
 3278               	.LBB194:
1023:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 3279               		.loc 1 1023 0
 3280 0d22 E3E0      		ldi r30,lo8(3)
 3281 0d24 F0E0      		ldi r31,0
 3282               	.L247:
 3283 0d26 89E0      		ldi r24,lo8(9)
 3284               	/* #APP */
 3285               	 ;  1023 "stk500boot.c" 1
 3286 0d28 8093 5700 		sts 87, r24
 3287 0d2c E491      		lpm r30, Z
 3288               		
 3289               	 ;  0 "" 2
 3290               	.LVL345:
 3291               	/* #NOAPP */
 3292               	.LBE194:
1026:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3293               		.loc 1 1026 0
 3294 0d2e 1A82      		std Y+2,__zero_reg__
 3295 0d30 00C0      		rjmp .L251
 3296               	.LVL346:
 3297               	.L146:
 3298               	.LBE191:
 3299               	.LBB196:
1037:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 3300               		.loc 1 1037 0
 3301 0d32 8D81      		ldd r24,Y+5
 3302               	.LVL347:
 3303               	.LBB197:
1038:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3304               		.loc 1 1038 0
 3305 0d34 836C      		ori r24,lo8(-61)
 3306               	.LVL348:
 3307 0d36 99E0      		ldi r25,lo8(9)
 3308               	/* #APP */
 3309               	 ;  1038 "stk500boot.c" 1
 3310 0d38 E1E0      		ldi r30, 1
 3311 0d3a F0E0      		ldi r31, 0
 3312 0d3c 082E      		mov r0, r24
 3313 0d3e 9093 5700 		sts 87, r25
 3314 0d42 E895      		spm
 3315               		
 3316               	 ;  0 "" 2
 3317               	/* #NOAPP */
 3318               	.L162:
 3319               	.LBE197:
1039:stk500boot.c  **** 						boot_spm_busy_wait();
 3320               		.loc 1 1039 0 discriminator 1
 3321 0d44 07B6      		in __tmp_reg__,0x37
 3322 0d46 00FC      		sbrc __tmp_reg__,0
 3323 0d48 00C0      		rjmp .L162
 3324               	.LVL349:
1042:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3325               		.loc 1 1042 0
 3326 0d4a 1A82      		std Y+2,__zero_reg__
1043:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3327               		.loc 1 1043 0
 3328 0d4c 1B82      		std Y+3,__zero_reg__
 3329               	.LVL350:
 3330               	.L248:
 3331               	.LBE196:
1041:stk500boot.c  **** 						msgLength		=	3;
 3332               		.loc 1 1041 0
 3333 0d4e 03E0      		ldi r16,lo8(3)
 3334 0d50 10E0      		ldi r17,0
1045:stk500boot.c  **** 					break;
 3335               		.loc 1 1045 0
 3336 0d52 00C0      		rjmp .L156
 3337               	.LVL351:
 3338               	.L142:
1051:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 3339               		.loc 1 1051 0
 3340 0d54 80EC      		ldi r24,lo8(-64)
 3341 0d56 8A83      		std Y+2,r24
1049:stk500boot.c  **** 					msgLength		=	2;
 3342               		.loc 1 1049 0
 3343 0d58 02E0      		ldi r16,lo8(2)
 3344 0d5a 10E0      		ldi r17,0
1048:stk500boot.c  **** 					eraseAddress	=	0;
 3345               		.loc 1 1048 0
 3346 0d5c CE5D      		subi r28,lo8(-290)
 3347 0d5e DE4F      		sbci r29,hi8(-290)
 3348 0d60 1882      		st Y,__zero_reg__
 3349 0d62 1982      		std Y+1,__zero_reg__
 3350 0d64 1A82      		std Y+2,__zero_reg__
 3351 0d66 1B82      		std Y+3,__zero_reg__
 3352 0d68 C252      		subi r28,lo8(290)
 3353 0d6a D140      		sbci r29,hi8(290)
1052:stk500boot.c  **** 					break;
 3354               		.loc 1 1052 0
 3355 0d6c 00C0      		rjmp .L156
 3356               	.LVL352:
 3357               	.L140:
1056:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 3358               		.loc 1 1056 0
 3359 0d6e 8A81      		ldd r24,Y+2
 3360 0d70 CB80      		ldd r12,Y+3
 3361 0d72 D12C      		mov r13,__zero_reg__
 3362 0d74 E12C      		mov r14,__zero_reg__
 3363 0d76 F12C      		mov r15,__zero_reg__
 3364 0d78 7601      		movw r14,r12
 3365 0d7a DD24      		clr r13
 3366 0d7c CC24      		clr r12
 3367 0d7e F82A      		or r15,r24
 3368 0d80 8D81      		ldd r24,Y+5
 3369 0d82 C82A      		or r12,r24
 3370 0d84 8C81      		ldd r24,Y+4
 3371 0d86 D82A      		or r13,r24
 3372 0d88 CC0C      		lsl r12
 3373 0d8a DD1C      		rol r13
 3374 0d8c EE1C      		rol r14
 3375 0d8e FF1C      		rol r15
 3376               	.L252:
 3377               	.LVL353:
1061:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3378               		.loc 1 1061 0
 3379 0d90 1A82      		std Y+2,__zero_reg__
 3380 0d92 00C0      		rjmp .L249
 3381               	.LVL354:
 3382               	.L143:
 3383               	.LBB198:
1067:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 3384               		.loc 1 1067 0
 3385 0d94 5A81      		ldd r21,Y+2
 3386 0d96 CD5C      		subi r28,lo8(-307)
 3387 0d98 DE4F      		sbci r29,hi8(-307)
 3388 0d9a 5883      		st Y,r21
 3389 0d9c C353      		subi r28,lo8(307)
 3390 0d9e D140      		sbci r29,hi8(307)
 3391 0da0 CE5C      		subi r28,lo8(-306)
 3392 0da2 DE4F      		sbci r29,hi8(-306)
 3393 0da4 1882      		st Y,__zero_reg__
 3394 0da6 C253      		subi r28,lo8(306)
 3395 0da8 D140      		sbci r29,hi8(306)
 3396 0daa 8B81      		ldd r24,Y+3
 3397 0dac CE5C      		subi r28,lo8(-306)
 3398 0dae DE4F      		sbci r29,hi8(-306)
 3399 0db0 A880      		ld r10,Y
 3400 0db2 B980      		ldd r11,Y+1
 3401 0db4 C253      		subi r28,lo8(306)
 3402 0db6 D140      		sbci r29,hi8(306)
 3403 0db8 A82A      		or r10,r24
 3404               	.LVL355:
1074:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 3405               		.loc 1 1074 0
 3406 0dba 2331      		cpi r18,lo8(19)
 3407 0dbc 01F0      		breq .+2
 3408 0dbe 00C0      		rjmp .L163
1077:stk500boot.c  **** 							if (eraseAddress < APP_END )
 3409               		.loc 1 1077 0
 3410 0dc0 CE5D      		subi r28,lo8(-290)
 3411 0dc2 DE4F      		sbci r29,hi8(-290)
 3412 0dc4 2881      		ld r18,Y
 3413 0dc6 3981      		ldd r19,Y+1
 3414 0dc8 4A81      		ldd r20,Y+2
 3415 0dca 5B81      		ldd r21,Y+3
 3416 0dcc C252      		subi r28,lo8(290)
 3417 0dce D140      		sbci r29,hi8(290)
 3418 0dd0 2115      		cp r18,__zero_reg__
 3419 0dd2 60EC      		ldi r22,-64
 3420 0dd4 3607      		cpc r19,r22
 3421 0dd6 63E0      		ldi r22,3
 3422 0dd8 4607      		cpc r20,r22
 3423 0dda 5105      		cpc r21,__zero_reg__
 3424 0ddc 00F4      		brsh .L164
1079:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
 3425               		.loc 1 1079 0
 3426 0dde 83E0      		ldi r24,lo8(3)
 3427               	/* #APP */
 3428               	 ;  1079 "stk500boot.c" 1
 3429 0de0 F901      		movw r30, r18
 3430 0de2 4093 5B00 		sts  91, r20
 3431 0de6 8093 5700 		sts 87, r24
 3432 0dea E895      		spm
 3433               		
 3434               	 ;  0 "" 2
 3435               	/* #NOAPP */
 3436               	.L165:
1080:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3437               		.loc 1 1080 0 discriminator 1
 3438 0dec 07B6      		in __tmp_reg__,0x37
 3439 0dee 00FC      		sbrc __tmp_reg__,0
 3440 0df0 00C0      		rjmp .L165
1081:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3441               		.loc 1 1081 0
 3442 0df2 CE5D      		subi r28,lo8(-290)
 3443 0df4 DE4F      		sbci r29,hi8(-290)
 3444 0df6 2881      		ld r18,Y
 3445 0df8 3981      		ldd r19,Y+1
 3446 0dfa 4A81      		ldd r20,Y+2
 3447 0dfc 5B81      		ldd r21,Y+3
 3448 0dfe C252      		subi r28,lo8(290)
 3449 0e00 D140      		sbci r29,hi8(290)
 3450 0e02 3F5F      		subi r19,-1
 3451 0e04 4F4F      		sbci r20,-1
 3452 0e06 5F4F      		sbci r21,-1
 3453 0e08 CE5D      		subi r28,lo8(-290)
 3454 0e0a DE4F      		sbci r29,hi8(-290)
 3455 0e0c 2883      		st Y,r18
 3456 0e0e 3983      		std Y+1,r19
 3457 0e10 4A83      		std Y+2,r20
 3458 0e12 5B83      		std Y+3,r21
 3459 0e14 C252      		subi r28,lo8(290)
 3460 0e16 D140      		sbci r29,hi8(290)
 3461               	.LVL356:
 3462               	.L164:
 3463 0e18 8B85      		ldd r24,Y+11
 3464 0e1a DE01      		movw r26,r28
 3465 0e1c 1D96      		adiw r26,13
 3466               	.LBE198:
 3467               	.LBB200:
 3468               	.LBB195:
1017:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3469               		.loc 1 1017 0 discriminator 1
 3470 0e1e 9701      		movw r18,r14
 3471 0e20 8601      		movw r16,r12
 3472               	.LBE195:
 3473               	.LBE200:
 3474               	.LBB201:
1090:stk500boot.c  **** 								boot_page_fill(address,data);
 3475               		.loc 1 1090 0 discriminator 1
 3476 0e22 41E0      		ldi r20,lo8(1)
 3477               	.L167:
 3478               	.LVL357:
 560:stk500boot.c  **** int main(void)
 3479               		.loc 1 560 0 discriminator 1
 3480 0e24 FD01      		movw r30,r26
 3481 0e26 3197      		sbiw r30,1
 3482               	.LVL358:
1089:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
 3483               		.loc 1 1089 0 discriminator 1
 3484 0e28 5081      		ld r21,Z
 3485 0e2a CB5C      		subi r28,lo8(-309)
 3486 0e2c DE4F      		sbci r29,hi8(-309)
 3487 0e2e 5883      		st Y,r21
 3488 0e30 C553      		subi r28,lo8(309)
 3489 0e32 D140      		sbci r29,hi8(309)
 3490 0e34 CC5C      		subi r28,lo8(-308)
 3491 0e36 DE4F      		sbci r29,hi8(-308)
 3492 0e38 1882      		st Y,__zero_reg__
 3493 0e3a C453      		subi r28,lo8(308)
 3494 0e3c D140      		sbci r29,hi8(308)
 3495 0e3e CC5C      		subi r28,lo8(-308)
 3496 0e40 DE4F      		sbci r29,hi8(-308)
 3497 0e42 6881      		ld r22,Y
 3498 0e44 7981      		ldd r23,Y+1
 3499 0e46 C453      		subi r28,lo8(308)
 3500 0e48 D140      		sbci r29,hi8(308)
 3501 0e4a 682B      		or r22,r24
 3502 0e4c CB01      		movw r24,r22
 3503               	.LVL359:
1090:stk500boot.c  **** 								boot_page_fill(address,data);
 3504               		.loc 1 1090 0 discriminator 1
 3505               	/* #APP */
 3506               	 ;  1090 "stk500boot.c" 1
 3507 0e4e 0C01      		movw  r0, r24
 3508 0e50 F801      		movw r30, r16
 3509 0e52 2093 5B00 		sts 91, r18
 3510 0e56 4093 5700 		sts 87, r20
 3511 0e5a E895      		spm
 3512 0e5c 1124      		clr  r1
 3513               		
 3514               	 ;  0 "" 2
 3515               	.LVL360:
1092:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
 3516               		.loc 1 1092 0 discriminator 1
 3517               	/* #NOAPP */
 3518 0e5e 0E5F      		subi r16,-2
 3519 0e60 1F4F      		sbci r17,-1
 3520 0e62 2F4F      		sbci r18,-1
 3521 0e64 3F4F      		sbci r19,-1
 3522               	.LVL361:
1093:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3523               		.loc 1 1093 0 discriminator 1
 3524 0e66 72E0      		ldi r23,2
 3525 0e68 A71A      		sub r10,r23
 3526 0e6a B108      		sbc r11,__zero_reg__
 3527               	.LVL362:
1094:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3528               		.loc 1 1094 0 discriminator 1
 3529 0e6c 01F0      		breq .L166
1087:stk500boot.c  **** 								highByte 	=	*p++;
 3530               		.loc 1 1087 0
 3531 0e6e 8C91      		ld r24,X
 3532 0e70 1296      		adiw r26,2
 3533 0e72 00C0      		rjmp .L167
 3534               	.L166:
1096:stk500boot.c  **** 							boot_page_write(tempaddress);
 3535               		.loc 1 1096 0
 3536 0e74 85E0      		ldi r24,lo8(5)
 3537               	/* #APP */
 3538               	 ;  1096 "stk500boot.c" 1
 3539 0e76 F601      		movw r30, r12
 3540 0e78 E092 5B00 		sts 91, r14
 3541 0e7c 8093 5700 		sts 87, r24
 3542 0e80 E895      		spm
 3543               		
 3544               	 ;  0 "" 2
 3545               	/* #NOAPP */
 3546               	.L168:
1097:stk500boot.c  **** 							boot_spm_busy_wait();
 3547               		.loc 1 1097 0 discriminator 1
 3548 0e82 07B6      		in __tmp_reg__,0x37
 3549 0e84 00FC      		sbrc __tmp_reg__,0
 3550 0e86 00C0      		rjmp .L168
1098:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3551               		.loc 1 1098 0
 3552 0e88 81E1      		ldi r24,lo8(17)
 3553               	/* #APP */
 3554               	 ;  1098 "stk500boot.c" 1
 3555 0e8a 8093 5700 		sts 87, r24
 3556 0e8e E895      		spm
 3557               		
 3558               	 ;  0 "" 2
 3559               	/* #NOAPP */
 3560 0e90 00C0      		rjmp .L169
 3561               	.LVL363:
 3562               	.L163:
 3563               	.LBB199:
1103:stk500boot.c  **** 							uint16_t ii = address >> 1;
 3564               		.loc 1 1103 0
 3565 0e92 A701      		movw r20,r14
 3566 0e94 9601      		movw r18,r12
 3567 0e96 5695      		lsr r21
 3568 0e98 4795      		ror r20
 3569 0e9a 3795      		ror r19
 3570 0e9c 2795      		ror r18
 3571 0e9e CA5D      		subi r28,lo8(-294)
 3572 0ea0 DE4F      		sbci r29,hi8(-294)
 3573 0ea2 2883      		st Y,r18
 3574 0ea4 3983      		std Y+1,r19
 3575 0ea6 4A83      		std Y+2,r20
 3576 0ea8 5B83      		std Y+3,r21
 3577 0eaa C652      		subi r28,lo8(294)
 3578 0eac D140      		sbci r29,hi8(294)
 3579               	.LVL364:
1105:stk500boot.c  **** 							while (size) {
 3580               		.loc 1 1105 0
 3581 0eae 00E0      		ldi r16,0
 3582 0eb0 10E0      		ldi r17,0
1068:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 3583               		.loc 1 1068 0
 3584 0eb2 4E01      		movw r8,r28
 3585 0eb4 3BE0      		ldi r19,11
 3586 0eb6 830E      		add r8,r19
 3587 0eb8 911C      		adc r9,__zero_reg__
1105:stk500boot.c  **** 							while (size) {
 3588               		.loc 1 1105 0
 3589 0eba 00C0      		rjmp .L170
 3590               	.LVL365:
 3591               	.L171:
1106:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3592               		.loc 1 1106 0
 3593 0ebc D401      		movw r26,r8
 3594 0ebe 6D91      		ld r22,X+
 3595 0ec0 4D01      		movw r8,r26
 3596               	.LVL366:
 560:stk500boot.c  **** int main(void)
 3597               		.loc 1 560 0
 3598 0ec2 CA5D      		subi r28,lo8(-294)
 3599 0ec4 DE4F      		sbci r29,hi8(-294)
 3600 0ec6 8881      		ld r24,Y
 3601 0ec8 9981      		ldd r25,Y+1
 3602 0eca C652      		subi r28,lo8(294)
 3603 0ecc D140      		sbci r29,hi8(294)
 3604 0ece 800F      		add r24,r16
 3605 0ed0 911F      		adc r25,r17
1106:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3606               		.loc 1 1106 0
 3607 0ed2 0E94 0000 		call __eewr_byte_m256rfr2
 3608               	.LVL367:
 3609 0ed6 0F5F      		subi r16,-1
 3610 0ed8 1F4F      		sbci r17,-1
 3611               	.LVL368:
 3612               	.L170:
1105:stk500boot.c  **** 							while (size) {
 3613               		.loc 1 1105 0 discriminator 1
 3614 0eda 0A15      		cp r16,r10
 3615 0edc 1B05      		cpc r17,r11
 3616 0ede 01F4      		brne .L171
 560:stk500boot.c  **** int main(void)
 3617               		.loc 1 560 0
 3618 0ee0 20E0      		ldi r18,0
 3619 0ee2 30E0      		ldi r19,0
 3620 0ee4 000F      		lsl r16
 3621 0ee6 111F      		rol r17
 3622 0ee8 221F      		rol r18
 3623 0eea 331F      		rol r19
 3624 0eec 0C0D      		add r16,r12
 3625 0eee 1D1D      		adc r17,r13
 3626 0ef0 2E1D      		adc r18,r14
 3627 0ef2 3F1D      		adc r19,r15
 3628               	.LVL369:
 3629               	.L169:
 3630               	.LBE199:
1113:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3631               		.loc 1 1113 0
 3632 0ef4 1A82      		std Y+2,__zero_reg__
 3633               	.LBE201:
1115:stk500boot.c  **** 					break;
 3634               		.loc 1 1115 0
 3635 0ef6 6801      		movw r12,r16
 3636 0ef8 7901      		movw r14,r18
 3637               	.LVL370:
 3638 0efa 00C0      		rjmp .L249
 3639               	.LVL371:
 3640               	.L144:
 3641               	.LBB202:
1120:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 3642               		.loc 1 1120 0
 3643 0efc BA81      		ldd r27,Y+2
 3644 0efe C95C      		subi r28,lo8(-311)
 3645 0f00 DE4F      		sbci r29,hi8(-311)
 3646 0f02 B883      		st Y,r27
 3647 0f04 C753      		subi r28,lo8(311)
 3648 0f06 D140      		sbci r29,hi8(311)
 3649 0f08 CA5C      		subi r28,lo8(-310)
 3650 0f0a DE4F      		sbci r29,hi8(-310)
 3651 0f0c 1882      		st Y,__zero_reg__
 3652 0f0e C653      		subi r28,lo8(310)
 3653 0f10 D140      		sbci r29,hi8(310)
 3654 0f12 8B81      		ldd r24,Y+3
 3655 0f14 CA5C      		subi r28,lo8(-310)
 3656 0f16 DE4F      		sbci r29,hi8(-310)
 3657 0f18 E881      		ld r30,Y
 3658 0f1a F981      		ldd r31,Y+1
 3659 0f1c C653      		subi r28,lo8(310)
 3660 0f1e D140      		sbci r29,hi8(310)
 3661 0f20 E82B      		or r30,r24
 3662 0f22 CF01      		movw r24,r30
 3663               	.LVL372:
1122:stk500boot.c  **** 						msgLength				=	size+3;
 3664               		.loc 1 1122 0
 3665 0f24 8C01      		movw r16,r24
 3666 0f26 0D5F      		subi r16,-3
 3667 0f28 1F4F      		sbci r17,-1
 3668               	.LVL373:
1124:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3669               		.loc 1 1124 0
 3670 0f2a 1A82      		std Y+2,__zero_reg__
 3671               	.LVL374:
1125:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3672               		.loc 1 1125 0
 3673 0f2c 2431      		cpi r18,lo8(20)
 3674 0f2e 01F4      		brne .L197
 3675 0f30 9E01      		movw r18,r28
 3676 0f32 2C5F      		subi r18,-4
 3677 0f34 3F4F      		sbci r19,-1
1124:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3678               		.loc 1 1124 0
 3679 0f36 DE01      		movw r26,r28
 3680 0f38 1396      		adiw r26,3
 3681               	.L173:
 3682               	.LVL375:
 3683               	.LBB203:
 3684               	.LBB204:
1133:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
 3685               		.loc 1 1133 0 discriminator 1
 3686               	/* #APP */
 3687               	 ;  1133 "stk500boot.c" 1
 3688 0f3a EBBE      		out 59, r14
 3689 0f3c F601      		movw r30, r12
 3690 0f3e 4791      		elpm r20, Z+
 3691 0f40 5691      		elpm r21, Z
 3692               		
 3693               	 ;  0 "" 2
 3694               	/* #NOAPP */
 3695               	.LBE204:
1137:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
 3696               		.loc 1 1137 0 discriminator 1
 3697 0f42 4C93      		st X,r20
 3698               	.LVL376:
1138:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3699               		.loc 1 1138 0 discriminator 1
 3700 0f44 F901      		movw r30,r18
 3701 0f46 5083      		st Z,r21
 560:stk500boot.c  **** int main(void)
 3702               		.loc 1 560 0 discriminator 1
 3703 0f48 1296      		adiw r26,2
 3704               	.LVL377:
1139:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3705               		.loc 1 1139 0 discriminator 1
 3706 0f4a F2E0      		ldi r31,2
 3707 0f4c CF0E      		add r12,r31
 3708 0f4e D11C      		adc r13,__zero_reg__
 3709 0f50 E11C      		adc r14,__zero_reg__
 3710 0f52 F11C      		adc r15,__zero_reg__
 3711               	.LVL378:
1140:stk500boot.c  **** 								size	-=	2;
 3712               		.loc 1 1140 0 discriminator 1
 3713 0f54 0297      		sbiw r24,2
 3714               	.LVL379:
 3715 0f56 2E5F      		subi r18,-2
 3716 0f58 3F4F      		sbci r19,-1
1141:stk500boot.c  **** 							}while (size);
 3717               		.loc 1 1141 0 discriminator 1
 3718 0f5a 0097      		sbiw r24,0
 3719 0f5c 01F4      		brne .L173
 3720 0f5e 00C0      		rjmp .L174
 3721               	.LVL380:
 3722               	.L197:
 3723               	.LBE203:
1125:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3724               		.loc 1 1125 0
 3725 0f60 9C01      		movw r18,r24
 3726 0f62 B701      		movw r22,r14
 3727 0f64 A601      		movw r20,r12
1124:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3728               		.loc 1 1124 0
 3729 0f66 FE01      		movw r30,r28
 3730 0f68 3396      		adiw r30,3
 3731               	.LVL381:
 3732               	.L172:
1147:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
 3733               		.loc 1 1147 0 discriminator 1
 3734 0f6a 41BD      		out 0x21,r20
1148:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3735               		.loc 1 1148 0 discriminator 1
 3736 0f6c 852E      		mov r8,r21
 3737 0f6e 962E      		mov r9,r22
 3738 0f70 A72E      		mov r10,r23
 3739 0f72 BB24      		clr r11
 3740 0f74 82BC      		out 0x22,r8
1149:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3741               		.loc 1 1149 0 discriminator 1
 3742 0f76 4F5F      		subi r20,-1
 3743 0f78 5F4F      		sbci r21,-1
 3744 0f7a 6F4F      		sbci r22,-1
 3745 0f7c 7F4F      		sbci r23,-1
 3746               	.LVL382:
1150:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3747               		.loc 1 1150 0 discriminator 1
 3748 0f7e F89A      		sbi 0x1f,0
1151:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3749               		.loc 1 1151 0 discriminator 1
 3750 0f80 A0B5      		in r26,0x20
 3751 0f82 A193      		st Z+,r26
 3752               	.LVL383:
1152:stk500boot.c  **** 								size--;
 3753               		.loc 1 1152 0 discriminator 1
 3754 0f84 2150      		subi r18,1
 3755 0f86 3109      		sbc r19,__zero_reg__
 3756               	.LVL384:
1153:stk500boot.c  **** 							} while (size);
 3757               		.loc 1 1153 0 discriminator 1
 3758 0f88 01F4      		brne .L172
 560:stk500boot.c  **** int main(void)
 3759               		.loc 1 560 0
 3760 0f8a 9C01      		movw r18,r24
 3761               	.LVL385:
 3762 0f8c 2150      		subi r18,1
 3763 0f8e 3109      		sbc r19,__zero_reg__
 3764 0f90 A901      		movw r20,r18
 3765               	.LVL386:
 3766 0f92 60E0      		ldi r22,0
 3767 0f94 70E0      		ldi r23,0
 3768 0f96 4F5F      		subi r20,-1
 3769 0f98 5F4F      		sbci r21,-1
 3770 0f9a 6F4F      		sbci r22,-1
 3771 0f9c 7F4F      		sbci r23,-1
 3772 0f9e C40E      		add r12,r20
 3773 0fa0 D51E      		adc r13,r21
 3774 0fa2 E61E      		adc r14,r22
 3775 0fa4 F71E      		adc r15,r23
 3776 0fa6 A3E0      		ldi r26,lo8(3)
 3777 0fa8 B0E0      		ldi r27,0
 3778 0faa AC0F      		add r26,r28
 3779 0fac BD1F      		adc r27,r29
 3780 0fae A80F      		add r26,r24
 3781 0fb0 B91F      		adc r27,r25
 3782               	.LVL387:
 3783               	.L174:
1155:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
 3784               		.loc 1 1155 0
 3785 0fb2 1C92      		st X,__zero_reg__
 3786               	.LVL388:
 3787               	.LBE202:
1157:stk500boot.c  **** 					break;
 3788               		.loc 1 1157 0
 3789 0fb4 00C0      		rjmp .L156
 3790               	.LVL389:
 3791               	.L136:
1161:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3792               		.loc 1 1161 0
 3793 0fb6 80EC      		ldi r24,lo8(-64)
 3794 0fb8 8A83      		std Y+2,r24
 3795               	.L249:
1160:stk500boot.c  **** 					msgLength		=	2;
 3796               		.loc 1 1160 0
 3797 0fba 02E0      		ldi r16,lo8(2)
 3798 0fbc 10E0      		ldi r17,0
 3799               	.LVL390:
 3800               	.L156:
1168:stk500boot.c  **** 			sendchar(MESSAGE_START);
 3801               		.loc 1 1168 0
 3802 0fbe 8BE1      		ldi r24,lo8(27)
 3803 0fc0 0E94 0000 		call sendchar
 3804               	.LVL391:
1171:stk500boot.c  **** 			sendchar(seqNum);
 3805               		.loc 1 1171 0
 3806 0fc4 C65D      		subi r28,lo8(-298)
 3807 0fc6 DE4F      		sbci r29,hi8(-298)
 3808 0fc8 8881      		ld r24,Y
 3809 0fca CA52      		subi r28,lo8(298)
 3810 0fcc D140      		sbci r29,hi8(298)
 3811 0fce 0E94 0000 		call sendchar
 3812               	.LVL392:
1175:stk500boot.c  **** 			sendchar(c);
 3813               		.loc 1 1175 0
 3814 0fd2 812F      		mov r24,r17
 3815 0fd4 0E94 0000 		call sendchar
 3816               	.LVL393:
1179:stk500boot.c  **** 			sendchar(c);
 3817               		.loc 1 1179 0
 3818 0fd8 802F      		mov r24,r16
 3819 0fda 0E94 0000 		call sendchar
 3820               	.LVL394:
1182:stk500boot.c  **** 			sendchar(TOKEN);
 3821               		.loc 1 1182 0
 3822 0fde 8EE0      		ldi r24,lo8(14)
 3823 0fe0 0E94 0000 		call sendchar
 3824               	.LVL395:
1176:stk500boot.c  **** 			checksum	^=	c;
 3825               		.loc 1 1176 0
 3826 0fe4 55E1      		ldi r21,lo8(21)
 3827 0fe6 952E      		mov r9,r21
 3828 0fe8 C65D      		subi r28,lo8(-298)
 3829 0fea DE4F      		sbci r29,hi8(-298)
 3830 0fec 2881      		ld r18,Y
 3831 0fee CA52      		subi r28,lo8(298)
 3832 0ff0 D140      		sbci r29,hi8(298)
 3833 0ff2 9226      		eor r9,r18
1180:stk500boot.c  **** 			checksum ^= c;
 3834               		.loc 1 1180 0
 3835 0ff4 9026      		eor r9,r16
1183:stk500boot.c  **** 			checksum ^= TOKEN;
 3836               		.loc 1 1183 0
 3837 0ff6 9126      		eor r9,r17
 3838               	.LVL396:
 560:stk500boot.c  **** int main(void)
 3839               		.loc 1 560 0
 3840 0ff8 41E0      		ldi r20,lo8(1)
 3841 0ffa 50E0      		ldi r21,0
 3842 0ffc 4C0F      		add r20,r28
 3843 0ffe 5D1F      		adc r21,r29
 3844 1000 040F      		add r16,r20
 3845 1002 151F      		adc r17,r21
 3846               	.LVL397:
1185:stk500boot.c  **** 			p	=	msgBuffer;
 3847               		.loc 1 1185 0
 3848 1004 5A01      		movw r10,r20
1186:stk500boot.c  **** 			while ( msgLength )
 3849               		.loc 1 1186 0
 3850 1006 00C0      		rjmp .L175
 3851               	.LVL398:
 3852               	.L176:
1188:stk500boot.c  **** 				c	=	*p++;
 3853               		.loc 1 1188 0
 3854 1008 D501      		movw r26,r10
 3855 100a 8D90      		ld r8,X+
 3856 100c 5D01      		movw r10,r26
 3857               	.LVL399:
1189:stk500boot.c  **** 				sendchar(c);
 3858               		.loc 1 1189 0
 3859 100e 882D      		mov r24,r8
 3860 1010 0E94 0000 		call sendchar
 3861               	.LVL400:
1190:stk500boot.c  **** 				checksum ^=c;
 3862               		.loc 1 1190 0
 3863 1014 9824      		eor r9,r8
 3864               	.LVL401:
 3865               	.L175:
1186:stk500boot.c  **** 			while ( msgLength )
 3866               		.loc 1 1186 0 discriminator 1
 3867 1016 A016      		cp r10,r16
 3868 1018 B106      		cpc r11,r17
 3869 101a 01F4      		brne .L176
1193:stk500boot.c  **** 			sendchar(checksum);
 3870               		.loc 1 1193 0
 3871 101c 892D      		mov r24,r9
 3872 101e 0E94 0000 		call sendchar
 3873               	.LVL402:
1194:stk500boot.c  **** 			seqNum++;
 3874               		.loc 1 1194 0
 3875 1022 C65D      		subi r28,lo8(-298)
 3876 1024 DE4F      		sbci r29,hi8(-298)
 3877 1026 2881      		ld r18,Y
 3878 1028 CA52      		subi r28,lo8(298)
 3879 102a D140      		sbci r29,hi8(298)
 3880 102c 2F5F      		subi r18,lo8(-(1))
 3881 102e C65D      		subi r28,lo8(-298)
 3882 1030 DE4F      		sbci r29,hi8(-298)
 3883 1032 2883      		st Y,r18
 3884 1034 CA52      		subi r28,lo8(298)
 3885 1036 D140      		sbci r29,hi8(298)
 3886               	.LVL403:
1198:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
 3887               		.loc 1 1198 0
 3888 1038 85B1      		in r24,0x5
 3889 103a 92E0      		ldi r25,lo8(2)
 3890 103c 8927      		eor r24,r25
 3891 103e 85B9      		out 0x5,r24
 3892               	.LVL404:
 3893 1040 40E0      		ldi r20,0
 3894 1042 50E0      		ldi r21,0
 743:stk500boot.c  **** 		while (!isLeave)
 3895               		.loc 1 743 0
 3896 1044 5520      		tst r5
 3897 1046 01F0      		breq .L52
 3898 1048 00C0      		rjmp .L53
 3899               	.LVL405:
 3900               	.L180:
 739:stk500boot.c  **** 	if (boot_state==1)
 3901               		.loc 1 739 0
 3902 104a C55D      		subi r28,lo8(-299)
 3903 104c DE4F      		sbci r29,hi8(-299)
 3904 104e 1982      		std Y+1,__zero_reg__
 3905 1050 1882      		st Y,__zero_reg__
 3906 1052 CB52      		subi r28,lo8(299)
 3907 1054 D140      		sbci r29,hi8(299)
 3908 1056 612C      		mov r6,__zero_reg__
 3909 1058 712C      		mov r7,__zero_reg__
 3910 105a C65D      		subi r28,lo8(-298)
 3911 105c DE4F      		sbci r29,hi8(-298)
 3912 105e 1882      		st Y,__zero_reg__
 3913 1060 CA52      		subi r28,lo8(298)
 3914 1062 D140      		sbci r29,hi8(298)
 3915 1064 912C      		mov r9,__zero_reg__
 3916 1066 212C      		mov r2,__zero_reg__
 3917 1068 312C      		mov r3,__zero_reg__
 3918 106a CE5D      		subi r28,lo8(-290)
 3919 106c DE4F      		sbci r29,hi8(-290)
 3920 106e 1882      		st Y,__zero_reg__
 3921 1070 1982      		std Y+1,__zero_reg__
 3922 1072 1A82      		std Y+2,__zero_reg__
 3923 1074 1B82      		std Y+3,__zero_reg__
 3924 1076 C252      		subi r28,lo8(290)
 3925 1078 D140      		sbci r29,hi8(290)
 3926 107a C12C      		mov r12,__zero_reg__
 3927 107c D12C      		mov r13,__zero_reg__
 3928 107e 7601      		movw r14,r12
 3929               	.LVL406:
 3930               	.LBB205:
 3931               	.LBB128:
 3932               	.LBB126:
 3933               	.LBB125:
 537:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 3934               		.loc 1 537 0
 3935 1080 60E0      		ldi r22,0
 3936 1082 70E0      		ldi r23,0
 3937 1084 CB01      		movw r24,r22
 3938               	/* #APP */
 3939               	 ;  537 "stk500boot.c" 1
 3940 1086 8BBF      		out 59, r24
 3941 1088 FB01      		movw r30, r22
 3942 108a 8791      		elpm r24, Z+
 3943 108c 9691      		elpm r25, Z
 3944               		
 3945               	 ;  0 "" 2
 3946               	/* #NOAPP */
 3947 108e C85C      		subi r28,lo8(-312)
 3948 1090 DE4F      		sbci r29,hi8(-312)
 3949 1092 9983      		std Y+1,r25
 3950 1094 8883      		st Y,r24
 3951 1096 C853      		subi r28,lo8(312)
 3952 1098 D140      		sbci r29,hi8(312)
 3953               	.LVL407:
 3954               	.L52:
 3955               	.LBE125:
 3956               	.LBE126:
 3957               	.LBE128:
 3958               	.LBE205:
 610:stk500boot.c  **** 	boot_timer	=	0;
 3959               		.loc 1 610 0 discriminator 1
 3960 109a 20E0      		ldi r18,0
 3961 109c 30E0      		ldi r19,0
 3962 109e 80E0      		ldi r24,0
 3963 10a0 0C94 0000 		jmp .L177
 3964               	.LVL408:
 3965               	.L53:
1217:stk500boot.c  **** 	sendchar('j');
 3966               		.loc 1 1217 0
 3967 10a4 8AE6      		ldi r24,lo8(106)
 3968 10a6 0E94 0000 		call sendchar
 3969               	.LVL409:
1225:stk500boot.c  **** 	sendchar(0x0d);
 3970               		.loc 1 1225 0
 3971 10aa 8DE0      		ldi r24,lo8(13)
 3972 10ac 0E94 0000 		call sendchar
 3973               	.LVL410:
1226:stk500boot.c  **** 	sendchar(0x0a);
 3974               		.loc 1 1226 0
 3975 10b0 8AE0      		ldi r24,lo8(10)
 3976 10b2 0E94 0000 		call sendchar
 3977               	.LVL411:
1228:stk500boot.c  **** 	delay_ms(100);
 3978               		.loc 1 1228 0
 3979 10b6 84E6      		ldi r24,lo8(100)
 3980 10b8 90E0      		ldi r25,0
 3981 10ba 0E94 0000 		call delay_ms
 3982               	.LVL412:
1233:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
 3983               		.loc 1 1233 0
 3984 10be 2198      		cbi 0x4,1
1234:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3985               		.loc 1 1234 0
 3986 10c0 2998      		cbi 0x5,1
1236:stk500boot.c  **** 	delay_ms(100);							// delay after exit
 3987               		.loc 1 1236 0
 3988 10c2 84E6      		ldi r24,lo8(100)
 3989 10c4 90E0      		ldi r25,0
 3990 10c6 0E94 0000 		call delay_ms
 3991               	.LVL413:
1240:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 3992               		.loc 1 1240 0
 3993               	/* #APP */
 3994               	 ;  1240 "stk500boot.c" 1
 3995 10ca 0000      		nop
 3996               	 ;  0 "" 2
1246:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
 3997               		.loc 1 1246 0
 3998               	/* #NOAPP */
 3999 10cc 8091 C000 		lds r24,192
 4000 10d0 8D7F      		andi r24,lo8(-3)
 4001 10d2 8093 C000 		sts 192,r24
1247:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 4002               		.loc 1 1247 0
 4003 10d6 81E1      		ldi r24,lo8(17)
 4004               	/* #APP */
 4005               	 ;  1247 "stk500boot.c" 1
 4006 10d8 8093 5700 		sts 87, r24
 4007 10dc E895      		spm
 4008               		
 4009               	 ;  0 "" 2
1250:stk500boot.c  **** 	asm volatile(
 4010               		.loc 1 1250 0
 4011               	 ;  1250 "stk500boot.c" 1
 4012 10de EE27      		clr	r30		
 4013 10e0 FF27      		clr	r31		
 4014 10e2 0994      		ijmp	
 4015               		
 4016               	 ;  0 "" 2
 4017               	/* #NOAPP */
 4018               	.L178:
 4019 10e4 00C0      		rjmp .L178
 4020               	.LVL414:
 4021               	.L185:
 792:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 4022               		.loc 1 792 0
 4023 10e6 4BE1      		ldi r20,lo8(27)
 4024 10e8 942E      		mov r9,r20
 4025               	.LVL415:
 791:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 4026               		.loc 1 791 0
 4027 10ea 81E0      		ldi r24,lo8(1)
 4028 10ec 0C94 0000 		jmp .L135
 4029               	.LVL416:
 4030               	.L186:
 837:stk500boot.c  **** 							msgParseState	=	ST_START;
 4031               		.loc 1 837 0
 4032 10f0 80E0      		ldi r24,0
 4033 10f2 0C94 0000 		jmp .L135
 4034               	.LVL417:
 4035               	.L187:
 846:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 4036               		.loc 1 846 0
 4037 10f6 86E0      		ldi r24,lo8(6)
 4038               	.LVL418:
 4039 10f8 0C94 0000 		jmp .L135
 4040               		.cfi_endproc
 4041               	.LFE13:
 4043               	.global	gTextMsg_END
 4044               		.section	.progmem.data,"a",@progbits
 4047               	gTextMsg_END:
 4048 0000 2A00      		.string	"*"
 4049               	.global	gTextMsg_HELP_MSG_Y
 4052               	gTextMsg_HELP_MSG_Y:
 4053 0002 593D 506F 		.string	"Y=Port blink"
 4053      7274 2062 
 4053      6C69 6E6B 
 4053      00
 4054               	.global	gTextMsg_HELP_MSG_V
 4057               	gTextMsg_HELP_MSG_V:
 4058 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4058      6F77 2069 
 4058      6E74 6572 
 4058      7275 7074 
 4058      2056 6563 
 4059               	.global	gTextMsg_HELP_MSG_R
 4062               	gTextMsg_HELP_MSG_R:
 4063 0028 523D 4475 		.string	"R=Dump RAM"
 4063      6D70 2052 
 4063      414D 00
 4064               	.global	gTextMsg_HELP_MSG_Q
 4067               	gTextMsg_HELP_MSG_Q:
 4068 0033 513D 5175 		.string	"Q=Quit"
 4068      6974 00
 4069               	.global	gTextMsg_HELP_MSG_L
 4072               	gTextMsg_HELP_MSG_L:
 4073 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4073      7374 2049 
 4073      2F4F 2050 
 4073      6F72 7473 
 4073      00
 4074               	.global	gTextMsg_HELP_MSG_H
 4077               	gTextMsg_HELP_MSG_H:
 4078 004b 483D 4865 		.string	"H=Help"
 4078      6C70 00
 4079               	.global	gTextMsg_HELP_MSG_F
 4082               	gTextMsg_HELP_MSG_F:
 4083 0052 463D 4475 		.string	"F=Dump FLASH"
 4083      6D70 2046 
 4083      4C41 5348 
 4083      00
 4084               	.global	gTextMsg_HELP_MSG_E
 4087               	gTextMsg_HELP_MSG_E:
 4088 005f 453D 4475 		.string	"E=Dump EEPROM"
 4088      6D70 2045 
 4088      4550 524F 
 4088      4D00 
 4089               	.global	gTextMsg_HELP_MSG_B
 4092               	gTextMsg_HELP_MSG_B:
 4093 006d 423D 426C 		.string	"B=Blink LED"
 4093      696E 6B20 
 4093      4C45 4400 
 4094               	.global	gTextMsg_HELP_MSG_AT
 4097               	gTextMsg_HELP_MSG_AT:
 4098 0079 403D 4545 		.string	"@=EEPROM test"
 4098      5052 4F4D 
 4098      2074 6573 
 4098      7400 
 4099               	.global	gTextMsg_HELP_MSG_QM
 4102               	gTextMsg_HELP_MSG_QM:
 4103 0087 3F3D 4350 		.string	"?=CPU stats"
 4103      5520 7374 
 4103      6174 7300 
 4104               	.global	gTextMsg_HELP_MSG_0
 4107               	gTextMsg_HELP_MSG_0:
 4108 0093 303D 5A65 		.string	"0=Zero addr"
 4108      726F 2061 
 4108      6464 7200 
 4109               	.global	gTextMsg_PORT
 4112               	gTextMsg_PORT:
 4113 009f 504F 5254 		.string	"PORT"
 4113      00
 4114               	.global	gTextMsg_EEPROMerrorCnt
 4117               	gTextMsg_EEPROMerrorCnt:
 4118 00a4 4545 2065 		.string	"EE err cnt="
 4118      7272 2063 
 4118      6E74 3D00 
 4119               	.global	gTextMsg_ReadingEEprom
 4122               	gTextMsg_ReadingEEprom:
 4123 00b0 5265 6164 		.string	"Reading EE"
 4123      696E 6720 
 4123      4545 00
 4124               	.global	gTextMsg_WriteToEEprom
 4127               	gTextMsg_WriteToEEprom:
 4128 00bb 5772 6974 		.string	"Writting EE"
 4128      7469 6E67 
 4128      2045 4500 
 4129               	.global	gTextMsg_SPACE
 4132               	gTextMsg_SPACE:
 4133 00c7 2000      		.string	" "
 4134               	.global	gTextMsg_MustBeLetter
 4137               	gTextMsg_MustBeLetter:
 4138 00c9 4D75 7374 		.string	"Must be a letter"
 4138      2062 6520 
 4138      6120 6C65 
 4138      7474 6572 
 4138      00
 4139               	.global	gTextMsg_PortNotSupported
 4142               	gTextMsg_PortNotSupported:
 4143 00da 506F 7274 		.string	"Port not supported"
 4143      206E 6F74 
 4143      2073 7570 
 4143      706F 7274 
 4143      6564 00
 4144               	.global	gTextMsg_WHAT_PORT
 4147               	gTextMsg_WHAT_PORT:
 4148 00ed 5768 6174 		.string	"What port:"
 4148      2070 6F72 
 4148      743A 00
 4149               	.global	gTextMsg_jmp
 4152               	gTextMsg_jmp:
 4153 00f8 6A6D 7020 		.string	"jmp "
 4153      00
 4154               	.global	gTextMsg_rjmp
 4157               	gTextMsg_rjmp:
 4158 00fd 726A 6D70 		.string	"rjmp  "
 4158      2020 00
 4159               	.global	gTextMsg_noVector
 4162               	gTextMsg_noVector:
 4163 0104 6E6F 2076 		.string	"no vector"
 4163      6563 746F 
 4163      7200 
 4164               	.global	gTextMsg_VECTOR_HEADER
 4167               	gTextMsg_VECTOR_HEADER:
 4168 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4168      2041 4444 
 4168      5220 2020 
 4168      6F70 2063 
 4168      6F64 6520 
 4169               	.global	gTextMsg_GCC_VERSION_STR
 4172               	gTextMsg_GCC_VERSION_STR:
 4173 0143 342E 372E 		.string	"4.7.2"
 4173      3200 
 4174               	.global	gTextMsg_AVR_LIBC_VER_STR
 4177               	gTextMsg_AVR_LIBC_VER_STR:
 4178 0149 312E 382E 		.string	"1.8.0"
 4178      3000 
 4179               	.global	gTextMsg_GCC_DATE_STR
 4182               	gTextMsg_GCC_DATE_STR:
 4183 014f 4E6F 7620 		.string	"Nov 20 2013"
 4183      3230 2032 
 4183      3031 3300 
 4184               	.global	gTextMsg_FUSE_BYTE_LOCK
 4187               	gTextMsg_FUSE_BYTE_LOCK:
 4188 015b 4C6F 636B 		.string	"Lock fuse   = "
 4188      2066 7573 
 4188      6520 2020 
 4188      3D20 00
 4189               	.global	gTextMsg_FUSE_BYTE_EXT
 4192               	gTextMsg_FUSE_BYTE_EXT:
 4193 016a 4578 7420 		.string	"Ext fuse    = "
 4193      6675 7365 
 4193      2020 2020 
 4193      3D20 00
 4194               	.global	gTextMsg_FUSE_BYTE_HIGH
 4197               	gTextMsg_FUSE_BYTE_HIGH:
 4198 0179 4869 6768 		.string	"High fuse   = "
 4198      2066 7573 
 4198      6520 2020 
 4198      3D20 00
 4199               	.global	gTextMsg_FUSE_BYTE_LOW
 4202               	gTextMsg_FUSE_BYTE_LOW:
 4203 0188 4C6F 7720 		.string	"Low fuse    = "
 4203      6675 7365 
 4203      2020 2020 
 4203      3D20 00
 4204               	.global	gTextMsg_CPU_SIGNATURE
 4207               	gTextMsg_CPU_SIGNATURE:
 4208 0197 4350 5520 		.string	"CPU ID      = "
 4208      4944 2020 
 4208      2020 2020 
 4208      3D20 00
 4209               	.global	gTextMsg_GCC_VERSION
 4212               	gTextMsg_GCC_VERSION:
 4213 01a6 4743 4320 		.string	"GCC Version = "
 4213      5665 7273 
 4213      696F 6E20 
 4213      3D20 00
 4214               	.global	gTextMsg_AVR_LIBC
 4217               	gTextMsg_AVR_LIBC:
 4218 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4218      4C69 6243 
 4218      2056 6572 
 4218      3D20 00
 4219               	.global	gTextMsg_AVR_ARCH
 4222               	gTextMsg_AVR_ARCH:
 4223 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4223      525F 4152 
 4223      4348 5F5F 
 4223      3D20 00
 4224               	.global	gTextMsg_CPU_Type
 4227               	gTextMsg_CPU_Type:
 4228 01d3 4350 5520 		.string	"CPU Type    = "
 4228      5479 7065 
 4228      2020 2020 
 4228      3D20 00
 4229               	.global	gTextMsg_COMPILED_ON
 4232               	gTextMsg_COMPILED_ON:
 4233 01e2 436F 6D70 		.string	"Compiled on = "
 4233      696C 6564 
 4233      206F 6E20 
 4233      3D20 00
 4234               	.global	gTextMsg_HUH
 4237               	gTextMsg_HUH:
 4238 01f1 4875 683F 		.string	"Huh?"
 4238      00
 4239               	.global	gTextMsg_Prompt
 4242               	gTextMsg_Prompt:
 4243 01f6 426F 6F74 		.string	"Bootloader>"
 4243      6C6F 6164 
 4243      6572 3E00 
 4244               	.global	gTextMsg_Explorer
 4247               	gTextMsg_Explorer:
 4248 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4248      696E 6F20 
 4248      6578 706C 
 4248      6F72 6572 
 4248      2073 746B 
 4249               	.global	gTextMsg_CPU_Name
 4252               	gTextMsg_CPU_Name:
 4253 0223 4154 6D65 		.string	"ATmega256rfr2"
 4253      6761 3235 
 4253      3672 6672 
 4253      3200 
 4254               		.comm	gEepromIndex,4,1
 4255               		.comm	gFlashIndex,4,1
 4256               		.comm	gRamIndex,4,1
 4257               	.global	app_start
 4258               		.section .bss
 4261               	app_start:
 4262 0000 0000      		.zero	2
 4263               		.section	.rodata
 4266               	CSWTCH.54:
 4267 0000 0F        		.byte	15
 4268 0001 02        		.byte	2
 4269 0002 0A        		.byte	10
 4270               		.text
 4271               	.Letext0:
 4272               		.file 3 "/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/includ
 4273               		.file 4 "/home/bob/avr8-gnu-toolchain-linux_x86_64/bin/../lib/gcc/avr/4.7.2/../../../../avr/includ
DEFINED SYMBOLS
                            *ABS*:0000000000000000 stk500boot.c
     /tmp/ccfL5CsS.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccfL5CsS.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccfL5CsS.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccfL5CsS.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccfL5CsS.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccfL5CsS.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccfL5CsS.s:12     .text:0000000000000000 sendchar
     /tmp/ccfL5CsS.s:40     .text.unlikely:0000000000000000 recchar
     /tmp/ccfL5CsS.s:63     .init9:0000000000000000 __jumpMain
     /tmp/ccfL5CsS.s:74     *ABS*:ffffffffffff81ff __stack
     /tmp/ccfL5CsS.s:804    .text.startup:0000000000000000 main
     /tmp/ccfL5CsS.s:113    .text:0000000000000018 delay_ms
     /tmp/ccfL5CsS.s:157    .text:0000000000000036 PrintFromPROGMEM
     /tmp/ccfL5CsS.s:220    .text:000000000000005e PrintNewLine
     /tmp/ccfL5CsS.s:241    .text.unlikely:000000000000000e PrintAvailablePort
     /tmp/ccfL5CsS.s:4112   .progmem.data:000000000000009f gTextMsg_PORT
     /tmp/ccfL5CsS.s:279    .text:000000000000006a PrintFromPROGMEMln
     /tmp/ccfL5CsS.s:299    .text:0000000000000072 PrintString
     /tmp/ccfL5CsS.s:342    .text:000000000000008a PrintHexByte
     /tmp/ccfL5CsS.s:398    .text.unlikely:0000000000000028 DumpHex.constprop.0
     /tmp/ccfL5CsS.s:704    .text:00000000000000b4 PrintDecInt
     /tmp/ccfL5CsS.s:4261   .bss:0000000000000000 app_start
                            *COM*:0000000000000004 gRamIndex
                            *COM*:0000000000000004 gFlashIndex
                            *COM*:0000000000000004 gEepromIndex
     /tmp/ccfL5CsS.s:4247   .progmem.data:0000000000000202 gTextMsg_Explorer
     /tmp/ccfL5CsS.s:4242   .progmem.data:00000000000001f6 gTextMsg_Prompt
     /tmp/ccfL5CsS.s:4107   .progmem.data:0000000000000093 gTextMsg_HELP_MSG_0
     /tmp/ccfL5CsS.s:4102   .progmem.data:0000000000000087 gTextMsg_HELP_MSG_QM
     /tmp/ccfL5CsS.s:4232   .progmem.data:00000000000001e2 gTextMsg_COMPILED_ON
     /tmp/ccfL5CsS.s:4182   .progmem.data:000000000000014f gTextMsg_GCC_DATE_STR
     /tmp/ccfL5CsS.s:4227   .progmem.data:00000000000001d3 gTextMsg_CPU_Type
     /tmp/ccfL5CsS.s:4252   .progmem.data:0000000000000223 gTextMsg_CPU_Name
     /tmp/ccfL5CsS.s:4222   .progmem.data:00000000000001c4 gTextMsg_AVR_ARCH
     /tmp/ccfL5CsS.s:4212   .progmem.data:00000000000001a6 gTextMsg_GCC_VERSION
     /tmp/ccfL5CsS.s:4172   .progmem.data:0000000000000143 gTextMsg_GCC_VERSION_STR
     /tmp/ccfL5CsS.s:4217   .progmem.data:00000000000001b5 gTextMsg_AVR_LIBC
     /tmp/ccfL5CsS.s:4177   .progmem.data:0000000000000149 gTextMsg_AVR_LIBC_VER_STR
     /tmp/ccfL5CsS.s:4207   .progmem.data:0000000000000197 gTextMsg_CPU_SIGNATURE
     /tmp/ccfL5CsS.s:4202   .progmem.data:0000000000000188 gTextMsg_FUSE_BYTE_LOW
     /tmp/ccfL5CsS.s:4197   .progmem.data:0000000000000179 gTextMsg_FUSE_BYTE_HIGH
     /tmp/ccfL5CsS.s:4192   .progmem.data:000000000000016a gTextMsg_FUSE_BYTE_EXT
     /tmp/ccfL5CsS.s:4187   .progmem.data:000000000000015b gTextMsg_FUSE_BYTE_LOCK
     /tmp/ccfL5CsS.s:4097   .progmem.data:0000000000000079 gTextMsg_HELP_MSG_AT
     /tmp/ccfL5CsS.s:4127   .progmem.data:00000000000000bb gTextMsg_WriteToEEprom
     /tmp/ccfL5CsS.s:4132   .progmem.data:00000000000000c7 gTextMsg_SPACE
     /tmp/ccfL5CsS.s:4122   .progmem.data:00000000000000b0 gTextMsg_ReadingEEprom
     /tmp/ccfL5CsS.s:4117   .progmem.data:00000000000000a4 gTextMsg_EEPROMerrorCnt
     /tmp/ccfL5CsS.s:4092   .progmem.data:000000000000006d gTextMsg_HELP_MSG_B
     /tmp/ccfL5CsS.s:4087   .progmem.data:000000000000005f gTextMsg_HELP_MSG_E
     /tmp/ccfL5CsS.s:4082   .progmem.data:0000000000000052 gTextMsg_HELP_MSG_F
     /tmp/ccfL5CsS.s:4077   .progmem.data:000000000000004b gTextMsg_HELP_MSG_H
     /tmp/ccfL5CsS.s:4072   .progmem.data:000000000000003a gTextMsg_HELP_MSG_L
     /tmp/ccfL5CsS.s:4067   .progmem.data:0000000000000033 gTextMsg_HELP_MSG_Q
     /tmp/ccfL5CsS.s:4062   .progmem.data:0000000000000028 gTextMsg_HELP_MSG_R
     /tmp/ccfL5CsS.s:4057   .progmem.data:000000000000000f gTextMsg_HELP_MSG_V
     /tmp/ccfL5CsS.s:4052   .progmem.data:0000000000000002 gTextMsg_HELP_MSG_Y
     /tmp/ccfL5CsS.s:4167   .progmem.data:000000000000010e gTextMsg_VECTOR_HEADER
     /tmp/ccfL5CsS.s:4162   .progmem.data:0000000000000104 gTextMsg_noVector
     /tmp/ccfL5CsS.s:4157   .progmem.data:00000000000000fd gTextMsg_rjmp
     /tmp/ccfL5CsS.s:4152   .progmem.data:00000000000000f8 gTextMsg_jmp
     /tmp/ccfL5CsS.s:4147   .progmem.data:00000000000000ed gTextMsg_WHAT_PORT
     /tmp/ccfL5CsS.s:4142   .progmem.data:00000000000000da gTextMsg_PortNotSupported
     /tmp/ccfL5CsS.s:4137   .progmem.data:00000000000000c9 gTextMsg_MustBeLetter
     /tmp/ccfL5CsS.s:4237   .progmem.data:00000000000001f1 gTextMsg_HUH
     /tmp/ccfL5CsS.s:4266   .rodata:0000000000000000 CSWTCH.54
     /tmp/ccfL5CsS.s:4047   .progmem.data:0000000000000000 gTextMsg_END

UNDEFINED SYMBOLS
__eerd_byte_m256rfr2
__divmodhi4
__udivmodsi4
__eewr_byte_m256rfr2
__do_copy_data
__do_clear_bss
